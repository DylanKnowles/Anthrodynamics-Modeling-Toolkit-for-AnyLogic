<?xml version="1.0" encoding="UTF-8"?>
<!--
*************************************************
	         AnyLogic Project File 
*************************************************	         
-->
<AnyLogicWorkspace WorkspaceVersion="1.9" AnyLogicVersion="8.3.2.201807061735" AlpVersion="8.3.1">
<Model>
	<Id>1520815173520</Id>
	<Name><![CDATA[AMTA]]></Name>
	<Description><![CDATA[== The Anthrodynamics Modeling Toolkit for AnyLogic (AMTA) ==

A modeling toolkit for dealing with people-problems in AnyLogic. Maintained by Dylan Knowles (www.dylanknowles.ca) and Anthrodynamics Simulation (www.anthrodynamics.ca). 

Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
	<EngineVersion>6</EngineVersion>
	<JavaPackageName><![CDATA[ca.anthrodynamics.toolkit.anylogic]]></JavaPackageName>
	<ModelTimeUnit><![CDATA[Year]]></ModelTimeUnit>
	<OptionLists>
		<OptionList>
			<Id>1520815570321</Id>
			<Name><![CDATA[SchofieldActivityLevel]]></Name>
			<Description><![CDATA[Schofield activity level. Used in BMR calculations to get the stress factor.

Sedentary.  Little to no exercise.  Inactive in both work and leisure. 	1.3 	1.3
Lightly active: Intensive exercise for at least 20 minutes once or twice per week or daily routine includes some walking.  Example: student.  Generally you do not exercise regularly, but you maintain a busy life style that requires you to walk frequently for long periods. 	1.6 	1.5
Moderately active: Intensive exercise for at least 20 to 45 minutes 3 to 4 times per week or a job with a lot of walking, or a moderate intensity job. 	1.7 	1.6
Very active: Intensive exercise for 60 minutes or greater 5 to 7 days per week.  Labor-intensive occupations also qualify for this level.  Labor-intensive occupations include construction work (brick laying, carpentry, general labor, etc.). Also farming, landscape worker or similar occupations. 	2.1 	1.9
Extremely active: Exceedingly active and/or very demanding activities:  Examples include:  athlete with an almost unstoppable training schedule with multiple training sessions throughout the day or a very demanding job, such as shoveling coal or working long hours on an assembly line. Generally, this level of activity is very difficult to achieve. 	2.4 	2.2]]></Description>
			<Option>
				<Id>1520815570323</Id>
				<Name><![CDATA[Sedentary]]></Name>
			</Option>
			<Option>
				<Id>1520815570325</Id>
				<Name><![CDATA[LightlyActive]]></Name>
			</Option>
			<Option>
				<Id>1520815570327</Id>
				<Name><![CDATA[ModeratelyActive]]></Name>
			</Option>
			<Option>
				<Id>1520815570329</Id>
				<Name><![CDATA[VeryActive]]></Name>
			</Option>
			<Option>
				<Id>1520815570331</Id>
				<Name><![CDATA[ExtremelyActive]]></Name>
			</Option>
		</OptionList>
	</OptionLists>
	<ActiveObjectClasses>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815340162</Id>
			<Name><![CDATA[Accumulator]]></Name>
			<Description><![CDATA[Accumulates a cost, QALY count, etc. over time. Ongoing costs can be submitted for recording, as can instantaneous costs.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import static ca.loif.niceassert.NiceAssert.*;
import java.util.function.DoubleSupplier;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.Queue;
import java.util.concurrent.Future;
import static ca.anthrodynamics.toolkit.anylogic.Exoskeleton.*;]]></Import>
			<Generic>true</Generic>
			<GenericParameter>
				<Id>1520815340157</Id>
				<Name><![CDATA[1520815340157]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[Key]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Key]]></GenericParameterLabel>
			</GenericParameter>
			<FlowchartBlock>true</FlowchartBlock>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1473580800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815340158</Id>
				<Name><![CDATA[scale]]></Name>
				<ExcludeFromBuild>true</ExcludeFromBuild>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815340234</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1520815340194</Id>
					<Name><![CDATA[accumulatedValue]]></Name>
					<X>190</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>false</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[initialValue]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1520815340196</Id>
					<Name><![CDATA[ongoingContributionsxx]]></Name>
					<X>200</X><Y>170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="false">
						<Type><![CDATA[ConcurrentHashMap<Key, DoubleSupplier>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ConcurrentHashMap<>()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1520815340198</Id>
					<Name><![CDATA[contributionsToDatexx]]></Name>
					<X>180</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="false">
						<Type><![CDATA[ConcurrentHashMap<Key, Double>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ConcurrentHashMap<>()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1520815340200</Id>
					<Name><![CDATA[timeOfLastContributionxx]]></Name>
					<X>210</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="false">
						<Type><![CDATA[ConcurrentHashMap<Key, Double>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ConcurrentHashMap<>()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1520815340202</Id>
					<Name><![CDATA[jobs]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>-40</X><Y>-80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[ExecutorService]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors())]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340226</Id>
					<Name><![CDATA[name]]></Name>
					<Description><![CDATA[The name of the accumulator.]]></Description>
					<X>20</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1520815340224</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340229</Id>
					<Name><![CDATA[initialValue]]></Name>
					<Description><![CDATA[The initial value of the accumulator.]]></Description>
					<X>20</X><Y>40</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[double]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[0.00]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340227</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340232</Id>
					<Name><![CDATA[monthsBetweenPeriodicAccumulation]]></Name>
					<X>20</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[double]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[3]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340230</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1520815340164</Id>
					<Name><![CDATA[ongoingContributions]]></Name>
					<Description><![CDATA[The ongoing contributions that are added up in this accumulator.]]></Description>
					<X>40</X><Y>170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="private" StaticVariable="false">
						<CollectionClass><![CDATA[LinkedHashMap]]></CollectionClass>
						<ElementClass><![CDATA[Key]]></ElementClass>
						<ValueElementClass><![CDATA[DoubleSupplier]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1520815340166</Id>
					<Name><![CDATA[timeOfLastContribution]]></Name>
					<X>40</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="false">
						<CollectionClass><![CDATA[LinkedHashMap]]></CollectionClass>
						<ElementClass><![CDATA[Key]]></ElementClass>
						<ValueElementClass><![CDATA[Double]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1520815340168</Id>
					<Name><![CDATA[contributionsToDate]]></Name>
					<Description><![CDATA[Contriibutions that each key has made to date.]]></Description>
					<X>20</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="private" StaticVariable="false">
						<CollectionClass><![CDATA[LinkedHashMap]]></CollectionClass>
						<ElementClass><![CDATA[Key]]></ElementClass>
						<ValueElementClass><![CDATA[Double]]></ValueElementClass>
					</Properties>

				</Variable>
			</Variables>
			<Events>
				<Event>
					<Id>1520815340223</Id>
					<Name><![CDATA[accumulatePeriodically]]></Name>
					<X>20</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="cyclic">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_YEAR]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1475654400000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[monthsBetweenPeriodicAccumulation]]></Code>
							<Unit Class="TimeUnits"><![CDATA[MONTH]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[/*jobs.submit(() -> {
	for (Key key : ongoingContributions.keySet())
		jobs.submit(() -> addOngoingContributionToAccumulatedValue(key));
});*/

/*for (Key key : ongoingContributions.keySet())
	addOngoingContributionToAccumulatedValue(key);*/
forceAccumulation();]]></Action>
					<Logging>false</Logging>
				</Event>
			</Events>
			<Functions>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340170</Id>
					<Name><![CDATA[log]]></Name>
					<Description><![CDATA[Adds a contribution instananeously to the accumulator, e.g., the cost of a single operation, a purchased vehicle, etc.

@param key
	The object or key to which a contribution is tied. This might be an object, string identifier, etc.
@param contribution
	The contribution to add.

@pre key != null
@pre contribution != NaN]]></Description>
					<X>20</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[key]]></Name>
						<Type><![CDATA[Key]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[contribution]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[// Preconditions.
assertNotNull("Key not provided.", key);
assertFalse("Contribution is NaN.", contribution == Double.NaN);

// Update before any change is made.
if (isTracking(key))
	addOngoingContributionToAccumulatedValue(key);

// Record
tryAddLabel(key);
accumulatedValue += contribution;
contributionsToDate.put(key, contribution + contributionsToDate.getOrDefault(key, 0d));
]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340172</Id>
					<Name><![CDATA[track]]></Name>
					<Description><![CDATA[Sets the contribution to track and accumulate for the given object (or key), e.g., a patient's discounted QALY's, a cost of maintenance for a labelled expense, etc.

@param key
	The object or key to which a contribution is associated. This might be an object, string identifier, etc.
@param contribution
	The value, which can vary with time, that the key adds to the accumulator for each model time unit.

@pre key != null
@pre contribution != null]]></Description>
					<X>20</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[key]]></Name>
						<Type><![CDATA[Key]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[contribution]]></Name>
						<Type><![CDATA[DoubleSupplier]]></Type>
					</Parameter>
					<Body><![CDATA[// Preconditions.
assertNotNull("Key not provided.", key);
assertNotNull("Contribution not provided.", contribution);

// Update before any change is made.
//updateAccumulatedValue();

// Record
tryAddLabel(key);
ongoingContributions.put(key, contribution);
timeOfLastContribution.put(key, time());]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340174</Id>
					<Name><![CDATA[getValue]]></Name>
					<Description><![CDATA[Returns the value of the accumulator.]]></Description>
					<X>20</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return accumulatedValue;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340176</Id>
					<Name><![CDATA[untrack]]></Name>
					<Description><![CDATA[Removes a tracked and accumulating value. Does NOT remove statistics on any logged values for this key to date, if any are collected (i.e., this simply stops accumulating more value for the key).

@param key
	The object or key to which a value is associated. This might be an object, string identifier, etc.

@pre key != null
@pre key has an associated value.]]></Description>
					<X>20</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[key]]></Name>
						<Type><![CDATA[Key]]></Type>
					</Parameter>
					<Body><![CDATA[// Preconditions.
assertNotNull("Key not provided.", key);
assertTrue("No contribution associated with the given key.", ongoingContributions.containsKey(key));

// Update before any change is made.
addOngoingContributionToAccumulatedValue(key);

// Remvoe the contribution
ongoingContributions.remove(key);

// Note: I used to remove this, but it's important to keep stats.
//timeOfLastContribution.remove(key, time());]]></Body>
				</Function>
				<Function AccessType="private" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340178</Id>
					<Name><![CDATA[getContributions]]></Name>
					<Description><![CDATA[Calculates the ongoing contributions and returns the sum.]]></Description>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>40</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[sum(ongoingContributions.keys(), thing -> getContributionsOf(thing));]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[boolean]]></ReturnType>
					<Id>1520815340180</Id>
					<Name><![CDATA[isTracking]]></Name>
					<Description><![CDATA[Returns true if the accumulator has any ongoing contributions tied to the given key.]]></Description>
					<X>90</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[key]]></Name>
						<Type><![CDATA[Key]]></Type>
					</Parameter>
					<Body><![CDATA[// Preconditions.
assertNotNull("Key not provided.", key);

return ongoingContributions.containsKey(key);]]></Body>
				</Function>
				<Function AccessType="private" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340182</Id>
					<Name><![CDATA[addOngoingContributionToAccumulatedValue]]></Name>
					<X>40</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[key]]></Name>
						<Type><![CDATA[Key]]></Type>
					</Parameter>
					<Body><![CDATA[double dt = time() - timeOfLastContribution.get(key);

//traceln("Adding " + (getContributionsOf(key) * dt));
Double contribution =  getOngoingContributionsOf(key) * dt;
accumulatedValue += contribution;

contributionsToDate.put(key, contribution + contributionsToDate.getOrDefault(key, 0d));
timeOfLastContribution.put(key, time());]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340184</Id>
					<Name><![CDATA[getOngoingContributionsOf]]></Name>
					<Description><![CDATA[Calculates the ongoing contributions of the given object.]]></Description>
					<X>40</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[key]]></Name>
						<Type><![CDATA[Key]]></Type>
					</Parameter>
					<Body><![CDATA[return ongoingContributions.get(key).getAsDouble();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340186</Id>
					<Name><![CDATA[getContributionsToDate]]></Name>
					<Description><![CDATA[Returns the contributions to date from the particular key, or zero if none.]]></Description>
					<X>40</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[key]]></Name>
						<Type><![CDATA[Key]]></Type>
					</Parameter>
					<Body><![CDATA[return contributionsToDate.getOrDefault(key, 0d);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340188</Id>
					<Name><![CDATA[expungeContributions]]></Name>
					<Description><![CDATA[Forgets all contributions related to the given key, clearing any data structures associated with it.

@post !isTracking(key)
@post getValue() has had key's contributions removed, getValue() after = getValue() before - contributionsToDate(key)]]></Description>
					<X>20</X><Y>400</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[key]]></Name>
						<Type><![CDATA[Key]]></Type>
					</Parameter>
					<Body><![CDATA[// Untrack the key.
if (isTracking(key))
	untrack(key);
	
// Eliminate all records of it.
ongoingContributions.remove(key);
timeOfLastContribution.remove(key);
accumulatedValue -= contributionsToDate.getOrDefault(key, 0d);
contributionsToDate.remove(key);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340190</Id>
					<Name><![CDATA[forceAccumulation]]></Name>
					<Description><![CDATA[Forces the accumulator to accumulate its values for all contributors.]]></Description>
					<X>380</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[for (Key key : ongoingContributions.keySet())
	addOngoingContributionToAccumulatedValue(key);
	
costChart.updateData();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340192</Id>
					<Name><![CDATA[getOngoingContributionsPTU]]></Name>
					<Description><![CDATA[Calculates the ongoing contributions of all currently contributing objects per model time unit.]]></Description>
					<X>230</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return ongoingContributions
	.values()
	.stream()
	.mapToDouble(f -> f.getAsDouble())
	.sum()
;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1537504631835</Id>
					<Name><![CDATA[tryAddLabel]]></Name>
					<X>190</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[key]]></Name>
						<Type><![CDATA[Key]]></Type>
					</Parameter>
					<Body><![CDATA[if (!contributionsToDate.containsKey(key)) {
	$(costChart).add(
		key.toString(), 
		spectrumColor(key.hashCode(), 37), 
		() -> getContributionsToDate(key), 
		this
	);
}]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520815340234</Id>
					<Name><![CDATA[connections]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>-100</X><Y>-120</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Shapes>
				<Group>
					<Id>1520815340204</Id>
					<Name><![CDATA[box]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>6.759</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<OnClickCode><![CDATA[viewArea.navigateTo();]]></OnClickCode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Shapes>
				<Polyline>
					<Id>1520815340206</Id>
					<Name><![CDATA[shapeBox]]></Name>
					<X>0</X><Y>13.518</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-1525489</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>13.518</X><Y>-6.759</Y><Z>0</Z></Point>
					   <Point><X>13.518</X><Y>-20.276</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-27.035</Y><Z>0</Z></Point>
					   <Point><X>-13.518</X><Y>-20.276</Y><Z>0</Z></Point>
					   <Point><X>-13.518</X><Y>-6.759</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1520815340208</Id>
					<Name><![CDATA[_ps2]]></Name>
					<X>0</X><Y>13.518</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>402653184</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-13.518</Y><Z>0</Z></Point>
					   <Point><X>13.518</X><Y>-20.276</Y><Z>0</Z></Point>
					   <Point><X>13.518</X><Y>-6.759</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1520815340210</Id>
					<Name><![CDATA[_ps3]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>1358954495</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>13.518</X><Y>-6.759</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-13.518</Y><Z>0</Z></Point>
					   <Point><X>-13.518</X><Y>-6.759</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1520815340212</Id>
					<Name><![CDATA[_ps4]]></Name>
					<X>0</X><Y>13.518</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-11913984</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor/>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>13.518</X><Y>-6.759</Y><Z>0</Z></Point>
					   <Point><X>13.518</X><Y>-20.276</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-27.035</Y><Z>0</Z></Point>
					   <Point><X>-13.518</X><Y>-20.276</Y><Z>0</Z></Point>
					   <Point><X>-13.518</X><Y>-6.759</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Line>
					<Id>1520815340214</Id>
					<Name><![CDATA[_ps5]]></Name>
					<X>-6.759</X><Y>-10.139</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-6324726</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<Dx>12</Dx>
					<Dy>5</Dy>
					<Dz>0</Dz>
				</Line>
				<Line>
					<Id>1520815340216</Id>
					<Name><![CDATA[_ps6]]></Name>
					<X>13.518</X><Y>-6.759</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-6324726</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<Dx>-14</Dx>
					<Dy>5</Dy>
					<Dz>0</Dz>
				</Line>
			</Shapes>

				</Group>
				<Text>
					<Id>1520815340218</Id>
					<Name><![CDATA[text1]]></Name>
					<X>20</X><Y>-12</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[<Name>]]></Text>
					<TextCode><![CDATA[name]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1520815340220</Id>
					<Name><![CDATA[text2]]></Name>
					<X>20</X><Y>3</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[<Value>]]></Text>
					<TextCode><![CDATA[format(accumulatedValue)]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Shapes>
			<Charts>
    			<TimeStackChart>
					<Id>1537503929659</Id>
					<Name><![CDATA[costChart]]></Name>
					<X>0</X><Y>-210</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1537516800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>260</Width>
					<Height>210</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>180</Width>
						<Height>100</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>50</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<TimeWindowsMovementType>MOVEMENT_WITH_TIME</TimeWindowsMovementType>		
					<TimeWindowUnits>MODEL_TIME_UNIT</TimeWindowUnits>
					<TimeWindowExpression><![CDATA[100]]></TimeWindowExpression>
					<SamplesToKeep>1000</SamplesToKeep>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>HUNDRED_PERCENTS</VerScaleType>
					<LabelFormat>MODEL_TIME_UNITS</LabelFormat>
    			</TimeStackChart>
			</Charts>
			<Areas>
				<Area>
					<Id>1537504451587</Id>
					<Name><![CDATA[viewArea]]></Name>
					<X>-40</X><Y>-210</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<Title><![CDATA[]]></Title>
					<Width>1000</Width>
					<Height>600</Height>
				</Area>
			</Areas>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815340303</Id>
			<Name><![CDATA[CollectionUtilities]]></Name>
			<Description><![CDATA[Various useful collection operations.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import org.apache.sanselan.color.ColorConversions;
import org.apache.sanselan.color.ColorCIELab;
import org.apache.sanselan.color.ColorXYZ;
import java.util.stream.Stream;
import java.util.function.*;
import java.util.stream.*;
import org.apache.commons.math3.distribution.EnumeratedDistribution;
import org.apache.commons.math3.util.Pair;
import static ca.loif.niceassert.NiceAssert.*;]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520815340298</Id>
				<Name><![CDATA[1520815340298]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowchartBlock>true</FlowchartBlock>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1471248000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815340299</Id>
				<Name><![CDATA[scale]]></Name>
				<ExcludeFromBuild>true</ExcludeFromBuild>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815340377</ConnectionsId>
			<Functions>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Stream<T>]]></ReturnType>
					<Id>1520815340305</Id>
					<Name><![CDATA[stream]]></Name>
					<Description><![CDATA[Returns a stream of the given values. ]]></Description>
					<X>20</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[values]]></Name>
						<Type><![CDATA[T...]]></Type>
					</Parameter>
					<Body><![CDATA[return list(values).stream();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> List<T>]]></ReturnType>
					<Id>1520815340307</Id>
					<Name><![CDATA[list]]></Name>
					<Description><![CDATA[Returns a list of the given values. ]]></Description>
					<X>20</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[values]]></Name>
						<Type><![CDATA[T...]]></Type>
					</Parameter>
					<Body><![CDATA[return Arrays.asList(values);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> List<T>]]></ReturnType>
					<Id>1520815340309</Id>
					<Name><![CDATA[iterable]]></Name>
					<Description><![CDATA[Returns a list of the given values. ]]></Description>
					<X>20</X><Y>170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[iterator]]></Name>
						<Type><![CDATA[Iterator<T>]]></Type>
					</Parameter>
					<Body><![CDATA[List<T> things = new LinkedList<>();
iterator.forEachRemaining(t -> things.add(t));
return things;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340311</Id>
					<Name><![CDATA[median]]></Name>
					<X>20</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[rawValues]]></Name>
						<Type><![CDATA[List<Double>]]></Type>
					</Parameter>
					<Body><![CDATA[if (rawValues == null || rawValues.size() == 0)
	return 0;

// Sort the list.
List<Double> values = new LinkedList<>(rawValues);
Collections.sort(values);

// Find the middle entry to get a median.
// Code graciously adapted from http://stackoverflow.com/questions/4191687/how-to-calculate-mean-median-mode-and-range-from-a-set-of-numbers
int middle = values.size() / 2;
if (values.size() % 2 == 1) {
	// If there's truly a median value (i.e., odd sized list), get it.
	return values.get(middle);
} else {
	// Otherwise, take an average.
	return (values.get(middle-1) + values.get(middle)) / 2.0;
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> double]]></ReturnType>
					<Id>1520815340313</Id>
					<Name><![CDATA[median]]></Name>
					<Description><![CDATA[Returns the median value for the objects in the collection.]]></Description>
					<X>40</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[List<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[rawValue]]></Name>
						<Type><![CDATA[Function<T, Double>]]></Type>
					</Parameter>
					<Body><![CDATA[return median(
	things
		.stream()
		.map(thing -> rawValue.apply(thing))
		.collect(Collectors.toList())
);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Stream<T>]]></ReturnType>
					<Id>1520815340315</Id>
					<Name><![CDATA[flatten]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>20</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Iterable<T>...]]></Type>
					</Parameter>
					<Body><![CDATA[Stream.Builder<T> builder = Stream.builder();
list(things).forEach(iterable -> iterable.forEach(thing -> builder.add(thing)));
return builder.build();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T extends Agent> Iterable<T>]]></ReturnType>
					<Id>1520815340317</Id>
					<Name><![CDATA[elementsOf]]></Name>
					<Description><![CDATA[Returns a list of the given values. ]]></Description>
					<X>20</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[service]]></Name>
						<Type><![CDATA[com.anylogic.libraries.processmodeling.Service<T>]]></Type>
					</Parameter>
					<Body><![CDATA[List<T> things = new LinkedList<>();
for (int i = 0; i < service.delaySize(); i += 1)
	things.add(service.delayGet(i));
for (int i = 0; i < service.queueSize(); i += 1)
	things.add(service.queueGet(i));
return things;

]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Iterable<T>]]></ReturnType>
					<Id>1520815340319</Id>
					<Name><![CDATA[flatten]]></Name>
					<X>40</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Iterable<T>...]]></Type>
					</Parameter>
					<Body><![CDATA[List<T> list = new LinkedList<>();
list(things).forEach(iterable -> iterable.forEach(thing -> list.add(thing)));
return list;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[<T extends Agent> Iterable<T>]]></ReturnType>
					<Id>1520815340321</Id>
					<Name><![CDATA[loop]]></Name>
					<Description><![CDATA[Runs the given command the given number of times.]]></Description>
					<X>20</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[times]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[toDo]]></Name>
						<Type><![CDATA[Consumer<Integer>]]></Type>
					</Parameter>
					<Body><![CDATA[for (int i = 0; i < times; i += 1)
	toDo.accept(i);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T extends Agent> Iterable<T>]]></ReturnType>
					<Id>1520815340323</Id>
					<Name><![CDATA[elementsOf]]></Name>
					<Description><![CDATA[Returns a list of the given values. ]]></Description>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>40</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[delay]]></Name>
						<Type><![CDATA[com.anylogic.libraries.processmodeling.Delay<T>]]></Type>
					</Parameter>
					<Body><![CDATA[List<T> things = new LinkedList<>();
for (int i = 0; i < delay.size(); i += 1)
	things.add(delay.get(i));

return things;

]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Collection<T>]]></ReturnType>
					<Id>1520815340325</Id>
					<Name><![CDATA[asCollection]]></Name>
					<X>20</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Body><![CDATA[List<T> list = new LinkedList<>();
things.forEach(list::add);
return list;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Collection<T>]]></ReturnType>
					<Id>1520815340327</Id>
					<Name><![CDATA[unmodifiable]]></Name>
					<X>20</X><Y>400</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Collection<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return Collections.unmodifiableCollection(things);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> List<T>]]></ReturnType>
					<Id>1520815340329</Id>
					<Name><![CDATA[shuffled]]></Name>
					<X>20</X><Y>370</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Body><![CDATA[List<T> list = new LinkedList<>();
things.forEach(list::add);
Collections.shuffle(list);
return list;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T, U> U]]></ReturnType>
					<Id>1520815340331</Id>
					<Name><![CDATA[ifNotNull]]></Name>
					<Description><![CDATA[Performs an action on the given object if it isn't null.

@return True if the action was performed, false otherwise.]]></Description>
					<X>20</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[thing]]></Name>
						<Type><![CDATA[T]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[returnThis]]></Name>
						<Type><![CDATA[Function<T, U>]]></Type>
					</Parameter>
					<Body><![CDATA[if (thing == null)
	return null;
else {
	return returnThis.apply(thing);
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> void]]></ReturnType>
					<Id>1520815340333</Id>
					<Name><![CDATA[forEach]]></Name>
					<Description><![CDATA[Convenience method for performing forEach actions on arrays, as this does not natively exist in Java.]]></Description>
					<X>20</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[array]]></Name>
						<Type><![CDATA[T[]]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[action]]></Name>
						<Type><![CDATA[Consumer<T>]]></Type>
					</Parameter>
					<Body><![CDATA[list(array).forEach(t -> action.accept(t));]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ void]]></ReturnType>
					<Id>1520815340335</Id>
					<Name><![CDATA[forEach]]></Name>
					<Description><![CDATA[Convenience method for performing forEach actions on Dimensions, as this does not natively exist in Java.]]></Description>
					<X>40</X><Y>480</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[array]]></Name>
						<Type><![CDATA[Dimension]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[action]]></Name>
						<Type><![CDATA[Consumer<Integer>]]></Type>
					</Parameter>
					<Body><![CDATA[// For each index in the Dimension, do something.
for (int i = 0; i < array.indexes.length; i += 1) {
	action.accept(array.indexes[i]);
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T extends Agent> Stream<T>]]></ReturnType>
					<Id>1520815340337</Id>
					<Name><![CDATA[streamOf]]></Name>
					<Description><![CDATA[Returns a stream of the given values. ]]></Description>
					<X>20</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentList<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return StreamSupport.stream(population.spliterator(), false);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Collection<T>]]></ReturnType>
					<Id>1520815340339</Id>
					<Name><![CDATA[pickNRandom]]></Name>
					<Description><![CDATA[Returns up to n random elements from the collection.]]></Description>
					<X>20</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[n]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[collection]]></Name>
						<Type><![CDATA[List<T>]]></Type>
					</Parameter>
					<Body><![CDATA[List<T> candidates = new LinkedList<>(collection);
List<T> randoms = new LinkedList<>();
Random r = new Random(System.nanoTime());
for (int i = 0; i < limitMax(n, collection.size()); i += 1) {

	int index = (int)(r.nextDouble() * candidates.size());
	
	randoms.add(candidates.get(index));
	candidates.remove(index);
}
return randoms;
]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Set<T>]]></ReturnType>
					<Id>1520815340341</Id>
					<Name><![CDATA[asSet]]></Name>
					<Description><![CDATA[Returns a list of the given values. ]]></Description>
					<X>80</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[values]]></Name>
						<Type><![CDATA[T...]]></Type>
					</Parameter>
					<Body><![CDATA[HashSet<T> set = new HashSet<>();
for (int i = 0; i < values.length; i += 1)
	set.add(values[i]);
return set;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> T]]></ReturnType>
					<Id>1520815340343</Id>
					<Name><![CDATA[weightedRandom]]></Name>
					<Description><![CDATA[Returns a random item with a probability associated with its weight.]]></Description>
					<X>390</X><Y>260</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[items]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[weight]]></Name>
						<Type><![CDATA[ToDoubleFunction<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return weightedRandom(getWeightedDistribution(items, weight), 1).get(0);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> List<T>]]></ReturnType>
					<Id>1520815340345</Id>
					<Name><![CDATA[weightedRandom]]></Name>
					<Description><![CDATA[Returns N random items where each item has a probability associated with its weight.

@pre number >= 1
@pre some item has a weight greater than zero
@pre items not empty]]></Description>
					<X>390</X><Y>280</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[items]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[weight]]></Name>
						<Type><![CDATA[ToDoubleFunction<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[number]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Body><![CDATA[return weightedRandom(getWeightedDistribution(items, weight), number);

/*// Simple preconditions
assertTrue("Number must be >= 1", number >= 1);

// Get N random items.
EnumeratedDistribution<T> dist = getWeightedDistribution(items, weight); 
List<T> results = new LinkedList<>();
Object[] out = dist.sample(number);
for (int i = 0; i < out.length; i += 1)
	results.add((T)out[i]);
return results;*/]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340347</Id>
					<Name><![CDATA[average]]></Name>
					<Description><![CDATA[Gets the average of the list of numbers.]]></Description>
					<X>20</X><Y>570</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[head]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[tail]]></Name>
						<Type><![CDATA[double...]]></Type>
					</Parameter>
					<Body><![CDATA[double sum = head;
for (int i = 0; i < tail.length; i += 1)
	sum += tail[i];
	
return sum/(tail.length + 1);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340349</Id>
					<Name><![CDATA[average]]></Name>
					<Description><![CDATA[Gets the average of the list of numbers.]]></Description>
					<X>20</X><Y>590</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[head]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[tail]]></Name>
						<Type><![CDATA[int...]]></Type>
					</Parameter>
					<Body><![CDATA[double sum = head;
for (int i = 0; i < tail.length; i += 1)
	sum += tail[i];
	
return sum/(tail.length + 1);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Collection<T>]]></ReturnType>
					<Id>1520815340351</Id>
					<Name><![CDATA[intersection]]></Name>
					<X>190</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[first]]></Name>
						<Type><![CDATA[Collection<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[second]]></Name>
						<Type><![CDATA[Collection<T>]]></Type>
					</Parameter>
					<Body><![CDATA[// Build a collection of any items in both collections.
Set<T> inBoth = new HashSet<>();
first.forEach(t -> {
	if (second.contains(t))
		inBoth.add(t);
});
return inBoth;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T extends Agent> Collection<T>]]></ReturnType>
					<Id>1520815340353</Id>
					<Name><![CDATA[pickNRandom]]></Name>
					<Description><![CDATA[Returns up to n random elements from the collection.]]></Description>
					<X>40</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[n]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[collection]]></Name>
						<Type><![CDATA[AgentList<T>]]></Type>
					</Parameter>
					<Body><![CDATA[Set<T> randoms = new HashSet<>();
for (int i = 0; i < limitMax(n, collection.size()); i += 1) {

	randoms.add(collection.randomExcept(randoms));
}
return randoms;
]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> T]]></ReturnType>
					<Id>1520815340355</Id>
					<Name><![CDATA[wrap]]></Name>
					<Description><![CDATA[Wraps the given logic with a try/catch block, re-throwing any exceptions as RuntimeExceptions.]]></Description>
					<X>360</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[function]]></Name>
						<Type><![CDATA[WrappedFunctions.Supplier<T>]]></Type>
					</Parameter>
					<Body><![CDATA[try {
	return function.get();
}
catch (Exception e) {
	throw new RuntimeException(e);
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> List<T>]]></ReturnType>
					<Id>1520815340357</Id>
					<Name><![CDATA[listExcluding]]></Name>
					<Description><![CDATA[Returns a list of items exluding the given values.]]></Description>
					<X>20</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[all]]></Name>
						<Type><![CDATA[T[]]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[exclusions]]></Name>
						<Type><![CDATA[T...]]></Type>
					</Parameter>
					<Body><![CDATA[List<T> exclusionsList = list(exclusions);
return filter(Arrays.asList(all), next -> exclusionsList.contains(next) == false);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Iterable<T>]]></ReturnType>
					<Id>1520815340359</Id>
					<Name><![CDATA[flattenAs]]></Name>
					<Description><![CDATA[Flattens the collections of things into a single iterable collection, converting all of the things to the common base class / interface.]]></Description>
					<X>200</X><Y>260</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Iterable<? extends T>...]]></Type>
					</Parameter>
					<Body><![CDATA[List<T> list = new LinkedList<>();
list(things).forEach(iterable -> iterable.forEach(thing -> list.add(thing)));
return list;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Stream<T>]]></ReturnType>
					<Id>1520815340361</Id>
					<Name><![CDATA[streamAs]]></Name>
					<Description><![CDATA[Flattens the collections of things into a stream, converting all of the things to the common base class / interface.]]></Description>
					<X>200</X><Y>280</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Iterable<? extends T>...]]></Type>
					</Parameter>
					<Body><![CDATA[List<T> list = new LinkedList<>();
list(things).forEach(iterable -> iterable.forEach(thing -> list.add(thing)));
return list.stream();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1520815340363</Id>
					<Name><![CDATA[catchToConsole]]></Name>
					<Description><![CDATA[Wraps the given logic with a try/catch block, simply printing the stacktrace to the console. Useful for some situations where silence is needed, e.g., in GUIs.]]></Description>
					<X>360</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[function]]></Name>
						<Type><![CDATA[WrappedFunctions.Runnable]]></Type>
					</Parameter>
					<Body><![CDATA[try {
	function.run();
}
catch (Exception e) {
	e.printStackTrace();
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> T[][]]]></ReturnType>
					<Id>1520815340365</Id>
					<Name><![CDATA[copy2D]]></Name>
					<Description><![CDATA[Creates a copy of the 2D array.]]></Description>
					<X>200</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[source]]></Name>
						<Type><![CDATA[T[][]]]></Type>
					</Parameter>
					<Body><![CDATA[T[][] destination = (T[][])new Object[source.length][];

for (int i = 0; i < source.length; i += 1) {
	destination[i] = Arrays.copyOf(source[i], source[i].length);
}

return destination;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double[][]]]></ReturnType>
					<Id>1520815340367</Id>
					<Name><![CDATA[copy2D]]></Name>
					<Description><![CDATA[Creates a copy of the 2D array.]]></Description>
					<X>220</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[source]]></Name>
						<Type><![CDATA[double[][]]]></Type>
					</Parameter>
					<Body><![CDATA[double[][] destination = new double[source.length][];

for (int i = 0; i < source.length; i += 1) {
	destination[i] = Arrays.copyOf(source[i], source[i].length);
}

return destination;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> String]]></ReturnType>
					<Id>1520815340369</Id>
					<Name><![CDATA[deepToString]]></Name>
					<Description><![CDATA[Converts an array type to a string.

@pre array.getClass().isArray() == true]]></Description>
					<X>200</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[array]]></Name>
						<Type><![CDATA[T]]></Type>
					</Parameter>
					<Body><![CDATA[// Ensure that the object is an array.
assertTrue("Object is not an array.", array.getClass().isArray());

// Deep string it.
if (array instanceof Object[]) 
	return Arrays.deepToString(((Object[])array)); 
else if (array instanceof boolean[])
	return Arrays.toString(((boolean[])array)); 
else if (array instanceof byte[])
	return Arrays.toString(((byte[])array)); 
else if (array instanceof short[])
	return Arrays.toString(((short[])array)); 
else if (array instanceof char[]) 
	return Arrays.toString(((char[])array)); 
else if (array instanceof int[])
	return Arrays.toString(((int[])array)); 
else if (array instanceof long[])
	return Arrays.toString(((long[])array)); 
else if (array instanceof float[])
	return Arrays.toString(((float[])array)); 
else if (array instanceof double[])
	return Arrays.toString(((double[])array)); 
else
	throw new IllegalArgumentException("Unhandled array type: " + array.getClass());]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> EnumeratedDistribution<T>]]></ReturnType>
					<Id>1520815340371</Id>
					<Name><![CDATA[getWeightedDistribution]]></Name>
					<Description><![CDATA[Returns a distribution of the given objects according to their weight. Used in {@link #weightedRandom}, but made public for operations where this weighting needs to be repeatedly calculated.

@pre some item has a weight greater than zero
@pre items not empty]]></Description>
					<X>410</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[items]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[weight]]></Name>
						<Type><![CDATA[ToDoubleFunction<T>]]></Type>
					</Parameter>
					<Body><![CDATA[// Simple preconditions
assertNotNull("Items not provided.", items);
assertNotNull("Weight not provided.", weight);

// Create a pairing for every item.
List<Pair<T, Double>> pairs = new LinkedList<>();
items.forEach(item -> {
	pairs.add(new Pair<>(item, weight.applyAsDouble(item)));
});
EnumeratedDistribution<T> dist = new EnumeratedDistribution<>(pairs);
return dist;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> T]]></ReturnType>
					<Id>1520815340373</Id>
					<Name><![CDATA[weightedRandom]]></Name>
					<Description><![CDATA[Returns a random item from the distribution.]]></Description>
					<X>390</X><Y>300</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[distribution]]></Name>
						<Type><![CDATA[EnumeratedDistribution<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return weightedRandom(distribution, 1).get(0);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> List<T>]]></ReturnType>
					<Id>1520815340375</Id>
					<Name><![CDATA[weightedRandom]]></Name>
					<Description><![CDATA[Returns N random items from the distribution.

@pre number >= 1
@pre some item has a weight greater than zero
@pre items not empty]]></Description>
					<X>390</X><Y>320</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[distribution]]></Name>
						<Type><![CDATA[EnumeratedDistribution<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[number]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Body><![CDATA[// Simple preconditions
assertTrue("Number must be >= 1", number >= 1);

// Get N random items.
List<T> results = new LinkedList<>();
Object[] out = distribution.sample(number);
for (int i = 0; i < out.length; i += 1)
	results.add((T)out[i]);
return results;]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520815340377</Id>
					<Name><![CDATA[connections]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>



		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815340384</Id>
			<Name><![CDATA[ExperimentUtilities]]></Name>
			<Description><![CDATA[Useful functions when outputting and visualizing data in experiments.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import org.apache.sanselan.color.ColorConversions;
import org.apache.sanselan.color.ColorCIELab;
import org.apache.sanselan.color.ColorXYZ;
import java.util.stream.Stream;
import java.util.function.*;
import java.util.stream.*;
import com.anylogic.libraries.processmodeling.Service;]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520815340379</Id>
				<Name><![CDATA[1520815340379]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowchartBlock>true</FlowchartBlock>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1479542400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815340380</Id>
				<Name><![CDATA[scale]]></Name>
				<ExcludeFromBuild>true</ExcludeFromBuild>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815340418</ConnectionsId>
			<Functions>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Color]]></ReturnType>
					<Id>1520815340386</Id>
					<Name><![CDATA[runColor]]></Name>
					<Description><![CDATA[Returns a color that corresponds to the given run name that is distinguishable on a graph from hues assigned to other runs. Intended largely to help make graph colors simpler to choose automatically when multiple runs are used to populate a graph.

@param runName
	The name of the run for which a color is needed.]]></Description>
					<X>20</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[runName]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[/* Supposedly we can distinguish ~150 unique hues, so 150 / 5 rounded to the 
 * closest prime number (i.e., to get unique colors while allowing for
 * sub-shades if needed for any particular run.) */
return spectrumColor(runName.hashCode(), 17);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340388</Id>
					<Name><![CDATA[plot]]></Name>
					<Description><![CDATA[Adds a dataset to a chart.]]></Description>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>20</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[plot]]></Name>
						<Type><![CDATA[TimePlot]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[color]]></Name>
						<Type><![CDATA[Color]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[valueSupplier]]></Name>
						<Type><![CDATA[DoubleSupplier]]></Type>
					</Parameter>
					<Body><![CDATA[final int StandardChartLineThickness = 2;
final int BigCapacity = 12 * 10; // 10 years monthly.
plot.addDataSet(
	new DataSet(BigCapacity) { 
		@Override
		public void update() {
			add(time(), valueSupplier.getAsDouble());
		}
	}, 
	facility.name,
	getFacilityColor(facility), 
	true, 
	Chart.INTERPOLATION_LINEAR, 
	StandardChartLineThickness, 
	Chart.POINT_NONE
);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ChartItem]]></ReturnType>
					<Id>1520815340390</Id>
					<Name><![CDATA[plot]]></Name>
					<Description><![CDATA[Quickly adds a dataset to a chart.]]></Description>
					<X>20</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[color]]></Name>
						<Type><![CDATA[Color]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[dataset]]></Name>
						<Type><![CDATA[DataSet]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[plot]]></Name>
						<Type><![CDATA[Chart2DPlot]]></Type>
					</Parameter>
					<Body><![CDATA[final int StandardChartLineThickness = 2;
plot.addDataSet(
	dataset, 
	label,
	color, 
	true, 
	Chart.INTERPOLATION_LINEAR, 
	StandardChartLineThickness, 
	Chart.POINT_NONE
);
return dataset;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ColorCIELab]]></ReturnType>
					<Id>1520815340392</Id>
					<Name><![CDATA[lab]]></Name>
					<X>40</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[color]]></Name>
						<Type><![CDATA[Color]]></Type>
					</Parameter>
					<Body><![CDATA[ColorXYZ xyz = ColorConversions.convertRGBtoXYZ(color.getRGB());
return ColorConversions.convertXYZtoCIELab(xyz);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Color]]></ReturnType>
					<Id>1520815340394</Id>
					<Name><![CDATA[shiftForPlot]]></Name>
					<Description><![CDATA[Produces a color for a graph by changing the default color of the run. Often, this is done by brightening or darkening the color in a good color space. E.g.:
0 - Red
1 - Dark Red
2 - Really Dark Red
...
]]></Description>
					<X>40</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[base]]></Name>
						<Type><![CDATA[Color]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[shift]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Body><![CDATA[ColorCIELab lab = lab(base);

for (int i = 0; i < shift; i += 1) {
	lab = new ColorCIELab(lab.L * 0.75, lab.a, lab.b);
}

return	new Color(
		ColorConversions.convertXYZtoRGB(
			ColorConversions.convertCIELabtoXYZ(lab)
));]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340396</Id>
					<Name><![CDATA[generateSlider]]></Name>
					<Description><![CDATA[Used to create a new slider overtop a backdrop. Very useful for dynamically generating a slider that is mapped to a particular set of inputs.]]></Description>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>20</X><Y>280</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[backdrop]]></Name>
						<Type><![CDATA[ShapeRectangle]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[configuration]]></Name>
						<Type><![CDATA[CareFacilityConfiguration]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[sliderMin]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[sliderValue]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[sliderMax]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[action]]></Name>
						<Type><![CDATA[BiConsumer<ShapeSlider, Double>]]></Type>
					</Parameter>
					<Body><![CDATA[if (1 == 1)
	throw new RuntimeException("Neither scaling to backdrop nor grouping into pane are implemented!");

// Readability constants.
final double MasterX = _masterSliderBackdrop.getX();
final double MasterY = _masterSliderBackdrop.getY();
final double XOffset = backdrop.getX();
final double YOffset = backdrop.getY();


// Copy all the shapes.
Collection<Shape> newControls = new LinkedList<>();

// The new slider.
ShapeSlider slider = new ShapeSlider(
	RunExperiment.this, true, 
	backdrop.getX(), backdrop.getY(),
	_masterSlider.getWidth(), _masterSlider.getHeight(),
	transparent, 
	true,
	false,
	sliderMin,
	sliderMax,
	ShapeControl.TYPE_INT
);
slider.setValue(sliderValue);
((JSlider)slider.getJComponent()).addChangeListener(e -> {
	action.accept(slider, slider.getValue());
});
newControls.add(slider);

ShapeTextField valueField = new ShapeTextField(
	RunExperiment.this, true,
	(XOffset + (_masterEditBox.getX() - MasterX)), 
	(YOffset + (_masterEditBox.getY() - MasterY)), 
	_masterEditBox.getWidth(), _masterEditBox.getHeight(),
	controlDefault, controlDefault, 
	true, __masterEditBox_Font 
); 
valueField.setText("" + slider.getIntValue());

((JSlider)slider.getJComponent()).addChangeListener(e -> {
	valueField.setText("" + slider.getIntValue(), false);
});

((JTextField)valueField.getJComponent()).addFocusListener(new FocusListener() {
	
	private final Color UnsavedColor = paleTurquoise;
	private final Color SavedColor = white;
	
	@Override public void focusGained(FocusEvent e) {
		valueField.setBackgroundColor(UnsavedColor);
	}
	
	@Override
	public void focusLost(FocusEvent e) {
		slider.setValue(valueField.getDoubleValue(), true);	
		valueField.setBackgroundColor(SavedColor);
	}
});

newControls.add(valueField);

// The min label.
ShapeText minLabel = _masterMinText.clone(); {

	minLabel.setX(XOffset + (_masterMinText.getX() - MasterX));
	minLabel.setY(YOffset + (_masterMinText.getY() - MasterY));
	minLabel.setText("" + (int)slider.getMin());
	
	newControls.add(minLabel);
}

// The max label.
ShapeText maxLabel = _masterMaxText.clone(); {

	maxLabel.setX(XOffset + (_masterMaxText.getX() - MasterX));
	maxLabel.setY(YOffset + (_masterMaxText.getY() - MasterY));
	maxLabel.setText("" + (int)slider.getMax());
	
	newControls.add(maxLabel);
}
	
// Add all new controls to the presentation.
newControls.forEach(c -> {
	presentation.add(c);
	autoGeneratedSliderControls.add(c);
});





]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[DataSet]]></ReturnType>
					<Id>1520815340398</Id>
					<Name><![CDATA[copyData]]></Name>
					<Description><![CDATA[Returns a copy of the data set.]]></Description>
					<X>20</X><Y>300</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[ds]]></Name>
						<Type><![CDATA[DataSet]]></Type>
					</Parameter>
					<Body><![CDATA[DataSet toReturn = new DataSet(ds.size());
for (int i = 0; i < ds.size(); i += 1) {
	toReturn.add(ds.getX(i), ds.getY(i));
}
return toReturn;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[ChartItem]]></ReturnType>
					<Id>1520815340400</Id>
					<Name><![CDATA[plot]]></Name>
					<Description><![CDATA[Quickly adds a dataset to a chart.]]></Description>
					<X>40</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[color]]></Name>
						<Type><![CDATA[Color]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[value]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[barChart]]></Name>
						<Type><![CDATA[Chart1D]]></Type>
					</Parameter>
					<Body><![CDATA[barChart.addDataItem(
	new DataItem() {{
		setValue(value);
	}},
	label,
	color
);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ChartItem]]></ReturnType>
					<Id>1520815340402</Id>
					<Name><![CDATA[plot]]></Name>
					<Description><![CDATA[Quickly adds a dataset to a chart.]]></Description>
					<X>40</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[color]]></Name>
						<Type><![CDATA[Color]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[dataset]]></Name>
						<Type><![CDATA[DataSet]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[plot]]></Name>
						<Type><![CDATA[TimePlot]]></Type>
					</Parameter>
					<Body><![CDATA[final int StandardChartLineThickness = 2;
plot.addDataSet(
	dataset, 
	label,
	color, 
	true, 
	Chart.INTERPOLATION_LINEAR, 
	StandardChartLineThickness, 
	Chart.POINT_NONE
);
return dataset;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[ChartItem]]></ReturnType>
					<Id>1520815340404</Id>
					<Name><![CDATA[plot]]></Name>
					<Description><![CDATA[Quickly adds a dataset to a chart.]]></Description>
					<X>40</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[color]]></Name>
						<Type><![CDATA[Color]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[valueSupplier]]></Name>
						<Type><![CDATA[Supplier<Double>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[barChart]]></Name>
						<Type><![CDATA[Chart1D]]></Type>
					</Parameter>
					<Body><![CDATA[barChart.addDataItem(
	new DataItem() {
		public void update() {
			setValue(valueSupplier.get());
		}
	},
	label,
	color
);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ChartItem]]></ReturnType>
					<Id>1520815340406</Id>
					<Name><![CDATA[plot1]]></Name>
					<Description><![CDATA[Quickly adds a dataset to a chart.]]></Description>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>160</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[color]]></Name>
						<Type><![CDATA[Color]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[valueSupplier]]></Name>
						<Type><![CDATA[Supplier<Double>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[plot]]></Name>
						<Type><![CDATA[Plot]]></Type>
					</Parameter>
					<Body><![CDATA[final int StandardChartLineThickness = 2;
plot.addDataSet(
	dataset, 
	label,
	color, 
	true, 
	Chart.INTERPOLATION_LINEAR, 
	StandardChartLineThickness, 
	Chart.POINT_NONE
);
return dataset;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[DataSet]]></ReturnType>
					<Id>1520815340408</Id>
					<Name><![CDATA[average]]></Name>
					<Description><![CDATA[Averages all data sets in the chart at each time point, returning a data set containing those averages. Averages are calculated at individual time points: if the data sets record data at uneven intervals, the resulting dataset may have artifacts. It is recommended that all datasets passed to this function have unified time steps.

E.g., if data set A = { 0=10, 1=20, 2=30 } and B = { 0=10, 1 = 40, 10 = 0 }, then the average is { 0=10, 1=30, 2=30, 10=0 }.]]></Description>
					<X>20</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[chart]]></Name>
						<Type><![CDATA[Plot]]></Type>
					</Parameter>
					<Body><![CDATA[/*// Get the average at all time points.
// Step 1: Get each run's value at each time point.
Map<Double, List<Double>> itemsByMeasurementTime = new LinkedHashMap<>(); 
for (int i = 0; i < chart.getCount(); i += 1) {
	DataSet next = chart.get(i);
	for (int j = 0; j < next.size(); j += 1) {
		double time = next.getX(j);
		double value = next.getY(j);
		if (itemsByMeasurementTime.containsKey(time) == false)
			itemsByMeasurementTime.put(time, new LinkedList<>());
			
		itemsByMeasurementTime.get(time).add(value);
	}
}

// Step 2: Create a single, unified dataset.
DataSet average = new DataSet(itemsByMeasurementTime.size());
itemsByMeasurementTime.forEach((time, valueList) -> {
	average.add(
		time,
		valueList.stream().mapToDouble(v -> v).average().getAsDouble()
	);
});

// Step 3: Return!
return average;*/
List<DataSet> data = new LinkedList<>();
for (int i = 0; i < chart.getCount(); i += 1) {
	data.add(chart.get(i));
}
return average(data);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[DataSet]]></ReturnType>
					<Id>1520815340410</Id>
					<Name><![CDATA[average]]></Name>
					<Description><![CDATA[Averages all data sets in the chart at each time point, returning a data set containing those averages. Averages are calculated at individual time points: if the data sets record data at uneven intervals, the resulting dataset may have artifacts. It is recommended that all datasets passed to this function have unified time steps.

E.g., if data set A = { 0=10, 1=20, 2=30 } and B = { 0=10, 1 = 40, 10 = 0 }, then the average is { 0=10, 1=30, 2=30, 10=0 }.]]></Description>
					<X>20</X><Y>370</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[data]]></Name>
						<Type><![CDATA[List<DataSet>]]></Type>
					</Parameter>
					<Body><![CDATA[// Get the average at all time points.
// Step 1: Get each run's value at each time point.
Map<Double, List<Double>> itemsByMeasurementTime = new LinkedHashMap<>(); 
for (int i = 0; i < data.size(); i += 1) {
	DataSet next = data.get(i);
	for (int j = 0; j < next.size(); j += 1) {
		double time = next.getX(j);
		double value = next.getY(j);
		if (itemsByMeasurementTime.containsKey(time) == false)
			itemsByMeasurementTime.put(time, new LinkedList<>());
			
		itemsByMeasurementTime.get(time).add(value);
	}
}

// Step 2: Create a single, unified dataset.
DataSet average = new DataSet(limitMin(100, itemsByMeasurementTime.size()));
itemsByMeasurementTime.forEach((time, valueList) -> {
	average.add(
		time,
		valueList.stream().mapToDouble(v -> v).average().getAsDouble()
	);
});

// Step 3: Return!
return average;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[DataSet]]></ReturnType>
					<Id>1520815340412</Id>
					<Name><![CDATA[average]]></Name>
					<Description><![CDATA[Averages all data sets in the chart at each time point, returning a data set containing those averages. Averages are calculated at individual time points: if the data sets record data at uneven intervals, the resulting dataset may have artifacts. It is recommended that all datasets passed to this function have unified time steps.

E.g., if data set A = { 0=10, 1=20, 2=30 } and B = { 0=10, 1 = 40, 10 = 0 }, then the average is { 0=10, 1=30, 2=30, 10=0 }.]]></Description>
					<X>20</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[chart]]></Name>
						<Type><![CDATA[TimePlot]]></Type>
					</Parameter>
					<Body><![CDATA[/*// Get the average at all time points.
// Step 1: Get each run's value at each time point.
Map<Double, List<Double>> itemsByMeasurementTime = new LinkedHashMap<>(); 
for (int i = 0; i < chart.getCount(); i += 1) {
	DataSet next = chart.get(i);
	for (int j = 0; j < next.size(); j += 1) {
		double time = next.getX(j);
		double value = next.getY(j);
		if (itemsByMeasurementTime.containsKey(time) == false)
			itemsByMeasurementTime.put(time, new LinkedList<>());
			
		itemsByMeasurementTime.get(time).add(value);
	}
}

// Step 2: Create a single, unified dataset.
DataSet average = new DataSet(itemsByMeasurementTime.size());
itemsByMeasurementTime.forEach((time, valueList) -> {
	average.add(
		time,
		valueList.stream().mapToDouble(v -> v).average().getAsDouble()
	);
});

// Step 3: Return!
return average;*/
List<DataSet> data = new LinkedList<>();
for (int i = 0; i < chart.getCount(); i += 1) {
	data.add(chart.get(i));
}
return average(data);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ChartItem]]></ReturnType>
					<Id>1520815340414</Id>
					<Name><![CDATA[plot]]></Name>
					<Description><![CDATA[Quickly adds a dataset to a chart.]]></Description>
					<X>40</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[color]]></Name>
						<Type><![CDATA[Color]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[dataset]]></Name>
						<Type><![CDATA[DataSet]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[plot]]></Name>
						<Type><![CDATA[TimeStackChart]]></Type>
					</Parameter>
					<Body><![CDATA[
plot.addDataSet(
	dataset, 
	label,
	color
);
return dataset;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ChartItem]]></ReturnType>
					<Id>1520815340416</Id>
					<Name><![CDATA[plot]]></Name>
					<Description><![CDATA[Quickly adds a dataset to a chart.

The final agent parameter is required to extract the current time.]]></Description>
					<X>100</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[color]]></Name>
						<Type><![CDATA[Color]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[valueSupplier]]></Name>
						<Type><![CDATA[Supplier<Double>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[plot]]></Name>
						<Type><![CDATA[TimeStackChart]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[return plot(
	label,
	color,
	new DataSet(10_000) {
		public void update() {
			add(agent.time(), valueSupplier.get());
		}
	},
	plot
);]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520815340418</Id>
					<Name><![CDATA[connections]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>



		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815340425</Id>
			<Name><![CDATA[GenericDot]]></Name>
			<Description><![CDATA[A customizable dot, which is often useful when visualizing people in models.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import java.util.function.*;]]></Import>
			<Generic>true</Generic>
			<GenericParameter>
				<Id>1520815340420</Id>
				<Name><![CDATA[1520815340420]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Linked object type]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1511510400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815340421</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815340461</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1520815340429</Id>
					<Name><![CDATA[timeOfLastClick]]></Name>
					<X>50</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[Double.NaN]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340438</Id>
					<Name><![CDATA[linkedObject]]></Name>
					<X>30</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[T]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1520815340436</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340441</Id>
					<Name><![CDATA[innerCircleFillColor]]></Name>
					<X>30</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Function<T, Color>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[obj -> lime]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340439</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>SEPARATE_SECTION</DelimeterType>
							<StartSection><![CDATA[Inner Circle]]></StartSection>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340444</Id>
					<Name><![CDATA[innerCircleBorderColor]]></Name>
					<X>30</X><Y>40</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Function<T, Color>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[obj -> black]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340442</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340447</Id>
					<Name><![CDATA[innerCircleRadius]]></Name>
					<X>30</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Function<T, Double>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[obj -> 10.0]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340445</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340450</Id>
					<Name><![CDATA[outerCircleFillColor]]></Name>
					<X>30</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Function<T, Color>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[obj -> green]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340448</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>SEPARATE_SECTION</DelimeterType>
							<StartSection><![CDATA[Outer Circle]]></StartSection>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340453</Id>
					<Name><![CDATA[outerCircleBorderColor]]></Name>
					<X>30</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Function<T, Color>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[obj -> transparent]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340451</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340456</Id>
					<Name><![CDATA[outerCircleRadius]]></Name>
					<X>30</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Function<T, Double>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[obj -> 15.0]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340454</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340459</Id>
					<Name><![CDATA[onClick]]></Name>
					<X>30</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Consumer<T>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[obj -> {}]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340457</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Functions>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1520815340427</Id>
					<Name><![CDATA[get]]></Name>
					<Description><![CDATA[Returns the object associated with this dot.]]></Description>
					<X>50</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return linkedObject;]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520815340461</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Shapes>
				<Group>
					<Id>1520815340431</Id>
					<Name><![CDATA[group]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<OnClickCode><![CDATA[onClick.accept(linkedObject);
timeOfLastClick = time();]]></OnClickCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Shapes>
				<Oval>
					<Id>1520815340433</Id>
					<Name><![CDATA[outerCircle]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineColorCode><![CDATA[outerCircleBorderColor.apply(linkedObject)]]></LineColorCode>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>15</RadiusX>
					<RadiusXCode><![CDATA[outerCircleRadius.apply(linkedObject)]]></RadiusXCode>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-16744448</FillColor>
					<FillColorCode><![CDATA[outerCircleFillColor.apply(linkedObject)]]></FillColorCode>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Oval>
					<Id>1520815340435</Id>
					<Name><![CDATA[innerCircle]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineColorCode><![CDATA[innerCircleBorderColor.apply(linkedObject)]]></LineColorCode>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>10</RadiusX>
					<RadiusXCode><![CDATA[innerCircleRadius.apply(linkedObject)]]></RadiusXCode>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-16711936</FillColor>
					<FillColorCode><![CDATA[innerCircleFillColor.apply(linkedObject)]]></FillColorCode>
					<FillMaterial>null</FillMaterial>
				</Oval>
			</Shapes>

				</Group>
			</Shapes>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815340468</Id>
			<Name><![CDATA[HealthUtilities]]></Name>
			<Description><![CDATA[Useful functions when building health models.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import java.lang.Runnable;
import static ca.loif.niceassert.NiceAssert.*;
import java.util.function.*;
import java.util.stream.StreamSupport;]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520815340463</Id>
				<Name><![CDATA[1520815340463]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowchartBlock>true</FlowchartBlock>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1478419200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815340464</Id>
				<Name><![CDATA[scale]]></Name>
				<ExcludeFromBuild>true</ExcludeFromBuild>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815340488</ConnectionsId>
			<Functions>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340470</Id>
					<Name><![CDATA[toDeathRatePerYear]]></Name>
					<Description><![CDATA[Converts the survival rate over the course of several years into a death rate per year.

@pre survivalRate in range [0,1] 
@pre numYears > 0]]></Description>
					<X>20</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[survivalRate]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[numYears]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[/* Convert the survival rate into a death rate.
 * An example:
 * - Survival rate over five years is 0.335 (i.e., survived year 1 AND year 2 AND year 3 AND year 4 AND year 5)
 * - Survival rate over one year is therefore 0.355 ^ (1/5) = 0.8035
 * - Death rate per year is therefore 1 - survival rate = 0.1965
 * - General formula: (survival rate)^(1/(years over which rate is measured))
 *
 */
 
return 1 - pow(survivalRate, 1 / numYears);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340474</Id>
					<Name><![CDATA[per100K]]></Name>
					<X>20</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[statistic]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[populationSize]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[return zidz(statistic, populationSize) * 100_000;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> T]]></ReturnType>
					<Id>1520815340476</Id>
					<Name><![CDATA[calculate]]></Name>
					<Description><![CDATA[Allows a complex value to be calculated. This function is provided because in AnyLogic there are often places that require a double value, but a few sub-steps would make legibility easier.]]></Description>
					<X>30</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[calculator]]></Name>
						<Type><![CDATA[Supplier<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return calculator.get();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Date]]></ReturnType>
					<Id>1520815340478</Id>
					<Name><![CDATA[at]]></Name>
					<X>30</X><Y>170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[year]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[zeroBasedMonth]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[day]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Body><![CDATA[return toDate(year, zeroBasedMonth, day, 0, 0, 0);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340480</Id>
					<Name><![CDATA[weightedAverage]]></Name>
					<Description><![CDATA[Returns a weighted average of the given values.

@pre values and weights same length.
@pre values & weights have at least one item.
@pre at least one weight > 0
@pre all weights non-negative]]></Description>
					<X>30</X><Y>260</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[values]]></Name>
						<Type><![CDATA[List<Double>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[weights]]></Name>
						<Type><![CDATA[List<Double>]]></Type>
					</Parameter>
					<Body><![CDATA[// Easy preconditions.
assertTrue("Values and weights must be same length.", values.size() == weights.size());
assertTrue("Must have at least one item.", values.size() > 0);

// Do the average.
double top = 0;
double bottom = 0;
for (int i = 0; i < values.size(); i += 1) {

	if (weights.get(i) < 0)
		fail("Weight["+i+"] was negative: " + weights.get(i));

	top += values.get(i) * weights.get(i);
	bottom += weights.get(i);
}
return zidz(top, bottom);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340482</Id>
					<Name><![CDATA[getBMRInKj]]></Name>
					<Description><![CDATA[Returns the basic metabolic rate of the person in Kj.]]></Description>
					<X>30</X><Y>300</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[person]]></Name>
						<Type><![CDATA[Person]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[activityLevel]]></Name>
						<Type><![CDATA[SchofieldActivityLevel]]></Type>
					</Parameter>
					<Body><![CDATA[// Use the appropriate calculation.
// All of this is from http://www.globalrph.com/schofield_equation_bmr.htm and http://www.nafwa.org/schofield.php
Function<Person, Double> equation = null;

// @optimization
double age = person.getAge();
double weightKg = person.getWeightKg();
double heightCm = person.getHeightCm();

// Do the calculation.
if (person.isMale()) {

	// Note that I haven't included the SEE's (standard error of estimates). For the >10 groups, this is 105, 153, 167, and 164 respectively.
	if (0 <= age && age < 3)
		equation = p -> 0.167 * weightKg + 15.174 * heightCm - 617.6; // Child: Accounts for height!
	else if (3 <= age && age < 10)
		equation = p -> 19.59 * weightKg + 1.303 * heightCm + 414.9; // Child: accounts for height!
	else if (10 <= age && age < 18)
		equation = p -> 17.686 * weightKg + 658.2;
	else if (18 <= age && age < 30)
		equation = p -> 15.057 * weightKg + 692.2;
	else if (30 <= age && age < 60)
		equation = p -> 11.472 * weightKg + 873.1;
	else if (age >= 60)
		equation = p -> 11.711 * weightKg + 587.7;
	else
		throw new Error("Unhandled age for male: " + age);
}
else {

	// Note that I haven't included the SEE's (standard error of estimates). For the >10 groups, this is 111, 119, 111, 108 respectively.
	if (0 <= age && age < 3)
		equation = p -> 16.252 * weightKg + 10.232 * heightCm - 413.5; // Child: Accounts for height!
	else if (3 <= age && age < 10)
		equation = p -> 16.969 * weightKg + 1.618 * heightCm + 371.2; // Child: accounts for height!
	else if (10 <= age && age < 18)
		equation = p -> 13.384 * weightKg + 692.6;
	else if (18 <= age && age < 30)
		equation = p -> 14.818 * weightKg + 486.6;
	else if (30 <= age && age < 60)
		equation = p -> 8.126 * weightKg + 845.6;
	else if (age >= 60)
		equation = p -> 9.082 * weightKg + 658.5;
	else
		throw new Error("Unhandled age for female: " + age);
}

// Adjust base BMR with activit level, convert the Calories to Kj, and return.
return 
	getBMRStressFactor(person, activityLevel)
	* equation
		.andThen(Calories -> Calories * 4.184)
		.apply(person)
;
]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340484</Id>
					<Name><![CDATA[getBMI]]></Name>
					<Description><![CDATA[Returns the person's BMI.]]></Description>
					<X>30</X><Y>340</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[person]]></Name>
						<Type><![CDATA[Person]]></Type>
					</Parameter>
					<Body><![CDATA[// Standard BMI formula.
double heightM = person.getHeightCm() / 100.0;
return person.getWeightKg() / heightM / heightM;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340486</Id>
					<Name><![CDATA[getBMRStressFactor]]></Name>
					<Description><![CDATA[Returns the Schofield stress factor associated with the person's current level of activity. For BMR calculations.]]></Description>
					<X>50</X><Y>320</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[person]]></Name>
						<Type><![CDATA[Person]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[activityLevel]]></Name>
						<Type><![CDATA[SchofieldActivityLevel]]></Type>
					</Parameter>
					<Body><![CDATA[// from http://www.globalrph.com/schofield_equation_bmr.htm
// Schofield equation.
switch (activityLevel) {
	case Sedentary: 		return (person.isMale()) ? 1.3 : 1.3;
	case LightlyActive: 	return (person.isMale()) ? 1.6 : 1.5;
	case ModeratelyActive: 	return (person.isMale()) ? 1.7 : 1.6;
	case VeryActive: 		return (person.isMale()) ? 2.1 : 1.9;
	case ExtremelyActive: 	return (person.isMale()) ? 2.4 : 2.2;
	default: 
		throw new Error("Unhandled activity level: " + activityLevel);
}]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520815340488</Id>
					<Name><![CDATA[connections]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>



		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815340495</Id>
			<Name><![CDATA[InterventionActionNode]]></Name>
			<Description><![CDATA[Part of an intervention diagram, which allows events to be scheduled and executed.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520815340490</Id>
				<Name><![CDATA[1520815340490]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1517558400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815340491</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815340515</ConnectionsId>
			<Variables>
				<Variable Class="Parameter">
					<Id>1520815340510</Id>
					<Name><![CDATA[description]]></Name>
					<X>30</X><Y>40</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA["Next action"]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340508</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340513</Id>
					<Name><![CDATA[action]]></Name>
					<X>30</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="ACTION">
						<Type><![CDATA[double]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1520815340511</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Ports>
				<Port>
					<Id>1520815340505</Id>
					<Name><![CDATA[previousActionPot]]></Name>
					<X>0</X><Y>-20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<IncomingMessageType><![CDATA[Object]]></IncomingMessageType>
					<OutgoingMessageType><![CDATA[Object]]></OutgoingMessageType>
					<CustomPort><![CDATA[false]]></CustomPort>
				</Port>
				<Port>
					<Id>1520815340507</Id>
					<Name><![CDATA[nextActionPort]]></Name>
					<X>0</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<IncomingMessageType><![CDATA[Object]]></IncomingMessageType>
					<OutgoingMessageType><![CDATA[Object]]></OutgoingMessageType>
					<CustomPort><![CDATA[false]]></CustomPort>
				</Port>
			</Ports>
			<Functions>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340497</Id>
					<Name><![CDATA[setExecuted]]></Name>
					<Description><![CDATA[Use to tell the node that is has been executed.]]></Description>
					<X>30</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[polyline.setFillColor(paleTurquoise);
oval3.setFillColor(paleTurquoise);]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520815340515</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Shapes>
				<Oval>
					<Id>1520815340499</Id>
					<Name><![CDATA[oval3]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>20</RadiusX>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-1</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Oval>
					<Id>1520815340501</Id>
					<Name><![CDATA[oval2]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>12</RadiusX>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-1</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Polyline>
					<Id>1520815340503</Id>
					<Name><![CDATA[polyline]]></Name>
					<X>-2</X><Y>-8</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-256</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>-5</X><Y>9</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>9</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>17</Y><Z>0</Z></Point>
					   <Point><X>8</X><Y>8</Y><Z>0</Z></Point>
					   <Point><X>3</X><Y>7</Y><Z>0</Z></Point>
					   <Point><X>9</X><Y>0</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
			</Shapes>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815340522</Id>
			<Name><![CDATA[InterventionAtNode]]></Name>
			<Description><![CDATA[Part of an intervention diagram, which allows events to be scheduled and executed.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import ca.anthrodynamics.toolkit.anylogic.TestSuite.CanScheduleCommands;
import java.util.function.Consumer;
import static ca.loif.niceassert.NiceAssert.*;
import java.util.stream.Collectors;
import static ca.anthrodynamics.toolkit.anylogic.CollectionUtilities.*;]]></Import>
			<StartupCode><![CDATA[text.setText(format(timeOfExecution)); ]]></StartupCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520815340517</Id>
				<Name><![CDATA[1520815340517]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1517558400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815340518</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815340551</ConnectionsId>
			<Variables>
				<Variable Class="Parameter">
					<Id>1520815340549</Id>
					<Name><![CDATA[timeOfExecution]]></Name>
					<X>35</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Date]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1520815340547</Id>
							<Label><![CDATA[timeOfExecution]]></Label>
							<EditorContolType>CALENDAR</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Ports>
				<Port>
					<Id>1520815340542</Id>
					<Name><![CDATA[nextTimePort]]></Name>
					<X>20</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<IncomingMessageType><![CDATA[Object]]></IncomingMessageType>
					<OutgoingMessageType><![CDATA[Object]]></OutgoingMessageType>
					<CustomPort><![CDATA[false]]></CustomPort>
				</Port>
				<Port>
					<Id>1520815340544</Id>
					<Name><![CDATA[beforeTime]]></Name>
					<X>-20</X><Y>0</Y>
					<Label><X>-64</X><Y>-2</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<IncomingMessageType><![CDATA[Object]]></IncomingMessageType>
					<OutgoingMessageType><![CDATA[Object]]></OutgoingMessageType>
					<CustomPort><![CDATA[false]]></CustomPort>
				</Port>
				<Port>
					<Id>1520815340546</Id>
					<Name><![CDATA[actionsPort]]></Name>
					<X>0</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<IncomingMessageType><![CDATA[Object]]></IncomingMessageType>
					<OutgoingMessageType><![CDATA[Object]]></OutgoingMessageType>
					<CustomPort><![CDATA[false]]></CustomPort>
				</Port>
			</Ports>
			<Functions>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[List<InterventionActionNode>]]></ReturnType>
					<Id>1520815340524</Id>
					<Name><![CDATA[getDownstreamActions]]></Name>
					<X>40</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[current]]></Name>
						<Type><![CDATA[InterventionActionNode]]></Type>
					</Parameter>
					<Body><![CDATA[// Are we the tail? If so, return just us.
List<InterventionActionNode> children = current
	.nextActionPort
	.getFlatLinks()
	.stream()
	.map(port -> {
		// Sanity check.
		assertTrue(
			current + " can only be connected to "+InterventionActionNode.class+" nodes.",
			port.getAgent() instanceof InterventionActionNode
		);
		return (InterventionActionNode)port.getAgent();
	})
	.collect(Collectors.toList())
;

if (children.isEmpty())
	return new LinkedList<>(list(current));
// Otherwise, return us prepended to the list we get.
else {
	// Sanity check: we can only have one outgoing connection.
	assertTrue(
		current + " can only have one outgoing connection of type "+InterventionActionNode.class+". "+
		"Instead, found " + children,
		children.size() == 1
	);
	// Prepend ourselves to the list of actions, and return.
	InterventionActionNode next = children.get(0);
	List<InterventionActionNode> times = getDownstreamActions(next);
	final int Head = 0;
	assertFalse(
		"Loop found: " + current + " is already in " + times,
		times.contains(current)
	);
	times.add(Head, current);
	return times;
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[List<InterventionActionNode>]]></ReturnType>
					<Id>1520815340526</Id>
					<Name><![CDATA[getActions]]></Name>
					<X>40</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//Sanity check.
assertTrue(
	this+" must be connected to a single "+InterventionActionNode.class+" node. ",
	actionsPort.getFlatLinks().size() == 1 && actionsPort.getFlatLinks().get(0).getAgent() instanceof InterventionActionNode
);

return getDownstreamActions((InterventionActionNode)actionsPort.getFlatLinks().get(0).getAgent());]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340528</Id>
					<Name><![CDATA[setExecuted]]></Name>
					<Description><![CDATA[Use to tell the node that is has been executed.]]></Description>
					<X>40</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[oval.setFillColor(paleTurquoise);]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520815340551</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Shapes>
				<Oval>
					<Id>1520815340530</Id>
					<Name><![CDATA[oval]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>20</RadiusX>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-1</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Oval>
					<Id>1520815340532</Id>
					<Name><![CDATA[oval1]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>15</RadiusX>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-1644806</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Oval>
					<Id>1520815340534</Id>
					<Name><![CDATA[oval2]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>12</RadiusX>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-1</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Oval>
					<Id>1520815340536</Id>
					<Name><![CDATA[oval3]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>DASHED</LineStyle>
					<RadiusX>10</RadiusX>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-1</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Polyline>
					<Id>1520815340538</Id>
					<Name><![CDATA[polyline]]></Name>
					<X>0</X><Y>-9</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>3</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor/>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>9</Y><Z>0</Z></Point>
					   <Point><X>5</X><Y>16</Y><Z>0</Z></Point>
					</Points>
					<Closed>false</Closed>
				</Polyline>
				<Text>
					<Id>1520815340540</Id>
					<Name><![CDATA[text]]></Name>
					<X>0</X><Y>-35</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[]]></Text>
					<TextCode><![CDATA[format(timeOfExecution)]]></TextCode>
					<Font>
						<Name>Roboto</Name>
						<Size>10</Size>
						<Style>0</Style>
					</Font>
					<Alignment>CENTER</Alignment>
				</Text>
			</Shapes>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815340558</Id>
			<Name><![CDATA[InterventionStartNode]]></Name>
			<Description><![CDATA[Part of an intervention diagram, which allows events to be scheduled and executed.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import ca.anthrodynamics.toolkit.anylogic.TestSuite.CanScheduleCommands;
import java.util.function.Consumer;
import static ca.loif.niceassert.NiceAssert.*;
import java.util.stream.Collectors;
import static ca.anthrodynamics.toolkit.anylogic.CollectionUtilities.*;]]></Import>
			<Implements><![CDATA[CanScheduleCommands]]></Implements>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520815340553</Id>
				<Name><![CDATA[1520815340553]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1517558400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815340554</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815340590</ConnectionsId>
			<Variables>
				<Variable Class="Parameter">
					<Id>1520815340588</Id>
					<Name><![CDATA[useInterventions]]></Name>
					<X>20</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340586</Id>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Ports>
				<Port>
					<Id>1520815340585</Id>
					<Name><![CDATA[moments]]></Name>
					<X>20</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<IncomingMessageType><![CDATA[Object]]></IncomingMessageType>
					<OutgoingMessageType><![CDATA[Object]]></OutgoingMessageType>
					<CustomPort><![CDATA[false]]></CustomPort>
				</Port>
			</Ports>
			<Events>
				<Event>
					<Id>1520815340583</Id>
					<Name><![CDATA[injectIntervention]]></Name>
					<X>20</X><Y>45</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="occuresOnce">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_YEAR]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1517558400000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[// For each time, add an action.
getActionTimes().forEach(time -> {

	// Append all the actions together.
	// Note: this is a consumer because we can't append runnables easily.
	Consumer<Object> fullAction = x -> time.setExecuted();
	for (InterventionActionNode action : time.getActions()) {
		fullAction = fullAction.andThen(x -> {
			if (action.description != null)
				traceln(action.description);
			action.action();
			action.setExecuted();
		});
	}

	// Schedule the action.
	scheduleCommand(
		dateToTime(time.timeOfExecution),
		getEngine().getTimeUnit(),
		fullAction
	);
});]]></Action>
				</Event>
			</Events>
			<DynamicEvents>
				<DynamicEventClass>
					<Id>1520815340580</Id>
					<Name><![CDATA[ScheduledCommand]]></Name>
					<X>40</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[action]]></Name>
						<Type><![CDATA[Consumer]]></Type>
					</Parameter>
					<Action><![CDATA[action.accept(this);]]></Action>
				</DynamicEventClass>
			</DynamicEvents>
			<Functions>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340560</Id>
					<Name><![CDATA[scheduleCommand]]></Name>
					<X>20</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[time]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[timeUnit]]></Name>
						<Type><![CDATA[TimeUnits]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[action]]></Name>
						<Type><![CDATA[Consumer]]></Type>
					</Parameter>
					<Body><![CDATA[//traceln("Command scheduled: " + time + " " + timeUnit);
create_ScheduledCommand(time, timeUnit, action);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[List<InterventionAtNode>]]></ReturnType>
					<Id>1520815340562</Id>
					<Name><![CDATA[getDownstreamActionTimes]]></Name>
					<X>20</X><Y>115</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[current]]></Name>
						<Type><![CDATA[InterventionAtNode]]></Type>
					</Parameter>
					<Body><![CDATA[// Are we the tail? If so, return just us.
List<InterventionAtNode> children = current
	.nextTimePort
	.getFlatLinks()
	.stream()
	.map(port -> {
		// Sanity check.
		assertTrue(
			current + " can only be connected to "+InterventionAtNode.class+" nodes.",
			port.getAgent() instanceof InterventionAtNode
		);
		return (InterventionAtNode)port.getAgent();
	})
	.collect(Collectors.toList())
;

if (children.isEmpty())
	return new LinkedList<>(list(current));
// Otherwise, return us prepended to the list we get.
else {
	// Sanity check: we can only have one outgoing connection.
	assertTrue(
		current + " can only have one outgoing connection of type "+InterventionAtNode.class+". "+
		"Instead, found " + children,
		children.size() == 1
	);

	// Prepend ourselves to the list of actions, ensuring that we are not already in it, and return.
	InterventionAtNode next = children.get(0);
	List<InterventionAtNode> times = getDownstreamActionTimes(next);
	final int Head = 0;
	assertFalse(
		"Loop found: " + current + " is already in " + times,
		times.contains(current)
	);
	times.add(Head, current);
	return times;
	
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[List<InterventionAtNode>]]></ReturnType>
					<Id>1520815340564</Id>
					<Name><![CDATA[getActionTimes]]></Name>
					<X>20</X><Y>135</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//Sanity check.
assertTrue(
	this+" must be connected to a single "+InterventionAtNode.class+" node. ",
	moments.getFlatLinks().size() == 1 && moments.getFlatLinks().get(0).getAgent() instanceof InterventionAtNode
);
	

return getDownstreamActionTimes((InterventionAtNode)moments.getFlatLinks().get(0).getAgent());]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520815340590</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Shapes>
				<Group>
					<Id>1520815340566</Id>
					<Name><![CDATA[group]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Shapes>
				<Oval>
					<Id>1520815340568</Id>
					<Name><![CDATA[oval]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>20</RadiusX>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-1</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Oval>
					<Id>1520815340570</Id>
					<Name><![CDATA[oval1]]></Name>
					<X>-0.444</X><Y>0.75</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>12.6665</RadiusX>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-14774017</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Polyline>
					<Id>1520815340572</Id>
					<Name><![CDATA[polyline1]]></Name>
					<X>-11</X><Y>-3</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-16744448</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>2.111</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>4.222</X><Y>1.875</Y><Z>0</Z></Point>
					   <Point><X>6.333</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>8.444</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>8.444</X><Y>3.75</Y><Z>0</Z></Point>
					   <Point><X>6.333</X><Y>5.625</Y><Z>0</Z></Point>
					   <Point><X>6.333</X><Y>7.5</Y><Z>0</Z></Point>
					   <Point><X>4.222</X><Y>5.625</Y><Z>0</Z></Point>
					   <Point><X>4.222</X><Y>7.5</Y><Z>0</Z></Point>
					   <Point><X>6.333</X><Y>9.375</Y><Z>0</Z></Point>
					   <Point><X>6.333</X><Y>11.25</Y><Z>0</Z></Point>
					   <Point><X>6.333</X><Y>13.125</Y><Z>0</Z></Point>
					   <Point><X>4.222</X><Y>13.125</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>9.375</Y><Z>0</Z></Point>
					   <Point><X>-2.111</X><Y>3.75</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1520815340574</Id>
					<Name><![CDATA[polyline2]]></Name>
					<X>10.111</X><Y>-4.875</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-16744448</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>-6.333</X><Y>1.875</Y><Z>0</Z></Point>
					   <Point><X>-4.222</X><Y>1.875</Y><Z>0</Z></Point>
					   <Point><X>-8.444</X><Y>3.75</Y><Z>0</Z></Point>
					   <Point><X>-8.444</X><Y>5.625</Y><Z>0</Z></Point>
					   <Point><X>-4.222</X><Y>5.625</Y><Z>0</Z></Point>
					   <Point><X>-8.444</X><Y>7.5</Y><Z>0</Z></Point>
					   <Point><X>-6.333</X><Y>11.25</Y><Z>0</Z></Point>
					   <Point><X>-4.222</X><Y>13.125</Y><Z>0</Z></Point>
					   <Point><X>-4.222</X><Y>15</Y><Z>0</Z></Point>
					   <Point><X>-2.111</X><Y>11.25</Y><Z>0</Z></Point>
					   <Point><X>-2.111</X><Y>9.375</Y><Z>0</Z></Point>
					   <Point><X>-2.111</X><Y>7.5</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>9.375</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>5.625</Y><Z>0</Z></Point>
					   <Point><X>2.111</X><Y>5.625</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1520815340576</Id>
					<Name><![CDATA[polyline3]]></Name>
					<X>-1</X><Y>-12</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-1</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>-5</X><Y>2</Y><Z>0</Z></Point>
					   <Point><X>-5</X><Y>5</Y><Z>0</Z></Point>
					   <Point><X>-1</X><Y>6</Y><Z>0</Z></Point>
					   <Point><X>1</X><Y>9</Y><Z>0</Z></Point>
					   <Point><X>5</X><Y>5</Y><Z>0</Z></Point>
					   <Point><X>10</X><Y>4</Y><Z>0</Z></Point>
					   <Point><X>6</X><Y>1</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1520815340578</Id>
					<Name><![CDATA[polyline]]></Name>
					<X>3</X><Y>-16</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-256</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>-5</X><Y>9</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>9</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>17</Y><Z>0</Z></Point>
					   <Point><X>8</X><Y>8</Y><Z>0</Z></Point>
					   <Point><X>3</X><Y>7</Y><Z>0</Z></Point>
					   <Point><X>9</X><Y>0</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
			</Shapes>

				</Group>
			</Shapes>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815340622</Id>
			<Name><![CDATA[StatisticUtilities]]></Name>
			<Description><![CDATA[Useful functions when trying to get statistics quickly on a group of agents or objects.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import static ca.loif.niceassert.NiceAssert.*;
import java.util.function.*;
import java.util.stream.*;]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520815340617</Id>
				<Name><![CDATA[1520815340617]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1504857600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815340618</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815340656</ConnectionsId>
			<Functions>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> double]]></ReturnType>
					<Id>1520815340624</Id>
					<Name><![CDATA[percentWhere]]></Name>
					<Description><![CDATA[Returns the percentage of the population with the given attribute.]]></Description>
					<X>30</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[predicate]]></Name>
						<Type><![CDATA[Predicate<T>]]></Type>
					</Parameter>
					<Body><![CDATA[double bottom = count(population, p -> true);
double top = count(population, predicate);
return zidz(top, bottom) * 100.0;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> double]]></ReturnType>
					<Id>1520815340626</Id>
					<Name><![CDATA[parallelPercentWhere]]></Name>
					<Description><![CDATA[Returns the percentage of the population with the given attribute.]]></Description>
					<X>30</X><Y>40</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[predicate]]></Name>
						<Type><![CDATA[Predicate<T>]]></Type>
					</Parameter>
					<Body><![CDATA[double bottom = StreamSupport
	.stream(population.spliterator(), true)
	.count()
;
double top = parallelCount(population, predicate);
return zidz(top, bottom) * 100.0;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> double]]></ReturnType>
					<Id>1520815340628</Id>
					<Name><![CDATA[parallelSum]]></Name>
					<Description><![CDATA[Returns the percentage of the population with the given attribute.]]></Description>
					<X>30</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[mapping]]></Name>
						<Type><![CDATA[ToDoubleFunction<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return StreamSupport
	.stream(population.spliterator(), true)
	.mapToDouble(mapping)
	.sum()
;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> double]]></ReturnType>
					<Id>1520815340630</Id>
					<Name><![CDATA[parallelCount]]></Name>
					<Description><![CDATA[Returns the percentage of the population with the given attribute.]]></Description>
					<X>30</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[predicate]]></Name>
						<Type><![CDATA[Predicate<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return parallelStreamWhere(
		population,
		predicate
	)
	.count()
;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Set<T>]]></ReturnType>
					<Id>1520815340632</Id>
					<Name><![CDATA[parallelCollect]]></Name>
					<Description><![CDATA[Returns the population with the given attribute. The operation is parallelized, which may result in speed improvements for large populations.]]></Description>
					<X>30</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[predicate]]></Name>
						<Type><![CDATA[Predicate<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return parallelStreamWhere(population, predicate)
	.collect(Collectors.toSet())
;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T, U> Set<U>]]></ReturnType>
					<Id>1520815340634</Id>
					<Name><![CDATA[parallelMapCollect]]></Name>
					<Description><![CDATA[Returns a mapping of the given population with the given attribute. The operation is parallelized, which may result in speed improvements for large populations.

@remarks
This function originated from the need to extract things like parents of children matching some criteria, people with dementia whose carers earned a certain income, etc.]]></Description>
					<X>30</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[predicate]]></Name>
						<Type><![CDATA[Predicate<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[mapper]]></Name>
						<Type><![CDATA[Function<T, U>]]></Type>
					</Parameter>
					<Body><![CDATA[return parallelStreamWhere(
		population,
		predicate
	)
	.map(mapper)
	.collect(Collectors.toSet())
;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T, U> Set<U>]]></ReturnType>
					<Id>1520815340636</Id>
					<Name><![CDATA[parallelMapCollect]]></Name>
					<Description><![CDATA[Returns a mapping of the given population. The operation is parallelized, which may result in speed improvements for large populations.

@remarks
This function originated from the need to extract things like parents of children matching some criteria, people with dementia whose carers earned a certain income, etc.]]></Description>
					<X>30</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[mapper]]></Name>
						<Type><![CDATA[Function<T, U>]]></Type>
					</Parameter>
					<Body><![CDATA[return StreamSupport.stream(population.spliterator(), true)
	.map(mapper)
	.collect(Collectors.toSet())
;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> Stream<T>]]></ReturnType>
					<Id>1520815340638</Id>
					<Name><![CDATA[parallelStreamWhere]]></Name>
					<Description><![CDATA[Returns the population with the given attribute as a stream. The operation is parallelized, which may result in speed improvements for large populations.]]></Description>
					<X>30</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[predicate]]></Name>
						<Type><![CDATA[Predicate<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return StreamSupport
	.stream(population.spliterator(), true)
	.filter(predicate)
;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T, U, V> Map<V, U>]]></ReturnType>
					<Id>1520815340640</Id>
					<Name><![CDATA[extract]]></Name>
					<Description><![CDATA[Takes a population, identifies the desired subpopulations, and then returns a statistic for each subpopulation. The subpopulations may overlap, and they do not need to cover the total population. This is useful for generating graphs that require statistics on a textured population.

The population is provided via a supplier

For example, population -> group by SES quintiles -> get disease statistics.
For example, population -> get all women, get all mothers, get all women who are not mothers  -> get depression statistics

@pre no argument null]]></Description>
					<X>450</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[transform]]></Name>
						<Type><![CDATA[Function<List<T>,U>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[groupHead]]></Name>
						<Type><![CDATA[Grouping<V, T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[groupTail]]></Name>
						<Type><![CDATA[Grouping<V, T>...]]></Type>
					</Parameter>
					<Body><![CDATA[return extract(() -> things, transform, groupHead, groupTail).get();
/*// Sanity check.
assertNotNull("Population not provided.", things);
assertNotNull("Statistic  generator not provided.", transform);
assertNotNull("At least one group needs to be provided.", groupHead);

// Extract each group.
List<Grouping<T, V>> groups = new LinkedList<>(Arrays.asList(groupTail));
groups.add(0, groupHead);
Map<V, U> result = new HashMap<>();
groups
	.parallelStream()
	.map(group -> 
		new Pair<Grouping<T, V>, U>(
			group,
			transform.apply(
				StreamSupport
					.stream(things.spliterator(), true)
					.filter(next -> group.isMember(next))
					.collect(Collectors.toList())
			)
		)
	)
	.sequential()
	.forEach(pair -> result.put(pair.getFirst().getIdentifier(), pair.getSecond()))
;

// Return the result.
return result;*/]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<ID, Type> Grouping<ID, Type>]]></ReturnType>
					<Id>1520815340642</Id>
					<Name><![CDATA[grouping]]></Name>
					<Description><![CDATA[Convenience function to create a Grouping, making extract() more declarative and readable.]]></Description>
					<X>470</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[id]]></Name>
						<Type><![CDATA[ID]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[membership]]></Name>
						<Type><![CDATA[Predicate<Type>]]></Type>
					</Parameter>
					<Body><![CDATA[return new Grouping<>(id, membership);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T, U, V> Supplier<Map<V, U>>]]></ReturnType>
					<Id>1520815340644</Id>
					<Name><![CDATA[extract]]></Name>
					<Description><![CDATA[Takes a population, identifies the desired subpopulations, and then returns a means of repeatedly gathering that statistic for each subpopulation. The subpopulations may overlap, and they do not need to cover the total population. This is useful for generating graphs that require statistics on a textured population.

The population is provided via a supplier

For example, population -> group by SES quintiles -> get disease statistics.
For example, population -> get all women, get all mothers, get all women who are not mothers  -> get depression statistics

@pre no argument null]]></Description>
					<X>450</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Supplier<Iterable<T>>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[transform]]></Name>
						<Type><![CDATA[Function<List<T>,U>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[groupHead]]></Name>
						<Type><![CDATA[Grouping<V, T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[groupTail]]></Name>
						<Type><![CDATA[Grouping<V, T>...]]></Type>
					</Parameter>
					<Body><![CDATA[// Sanity check.
assertNotNull("Population supplier not provided.", things);
assertNotNull("Statistic  generator not provided.", transform);
assertNotNull("At least one group needs to be provided.", groupHead);

// Extract each group.
List<Grouping<V, T>> groups = new LinkedList<>(Arrays.asList(groupTail));
groups.add(0, groupHead);
return extract(things, transform, groups);
/*Supplier<Map<V, U>> ongoingResult = () -> {
	Map<V,U> result = new HashMap<>();
	Iterable<T> concreteThings = things.get();
	groups
		.parallelStream()
		.map(group -> 
			new Pair<Grouping<T, V>, U>(
				group,
				transform.apply(
					StreamSupport
						.stream(concreteThings.spliterator(), true)
						.filter(next -> group.isMember(next))
						.collect(Collectors.toList())
				)
			)
		)
		.sequential()
		.forEach(pair -> result.put(pair.getFirst().getIdentifier(), pair.getSecond()))
	;
	return result;
};

// Return the result.
return ongoingResult;*/]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T, U, V> Supplier<Map<V, U>>]]></ReturnType>
					<Id>1520815340646</Id>
					<Name><![CDATA[extract]]></Name>
					<Description><![CDATA[Takes a population, identifies the desired subpopulations, and then returns a means of repeatedly gathering that statistic for each subpopulation. The subpopulations may overlap, and they do not need to cover the total population. This is useful for generating graphs that require statistics on a textured population.

The population is provided via a supplier

For example, population -> group by SES quintiles -> get disease statistics.
For example, population -> get all women, get all mothers, get all women who are not mothers  -> get depression statistics

@pre no argument null]]></Description>
					<X>450</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Supplier<Iterable<T>>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[transform]]></Name>
						<Type><![CDATA[Function<List<T>,U>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[groups]]></Name>
						<Type><![CDATA[List<Grouping<V, T>>]]></Type>
					</Parameter>
					<Body><![CDATA[// Sanity check.
assertNotNull("Population supplier not provided.", things);
assertNotNull("Statistic  generator not provided.", transform);
assertNotNull("At least one group needs to be provided.", groups != null &&  groups.size() > 0);

// Extract each group.
Supplier<Map<V, U>> ongoingResult = () -> {
	Map<V,U> result = new HashMap<>();
	Iterable<T> concreteThings = things.get();
	groups
		.parallelStream()
		.map(group -> 
			new Pair<Grouping<V, T>, U>(
				group,
				transform.apply(
					StreamSupport
						.stream(concreteThings.spliterator(), true)
						.filter(next -> group.isMember(next))
						.collect(Collectors.toList())
				)
			)
		)
		.sequential()
		.forEach(pair -> result.put(pair.getFirst().getIdentifier(), pair.getSecond()))
	;
	return result;
};

// Return the result.
return ongoingResult;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T, U> Supplier<Map<List<Object>, U>>]]></ReturnType>
					<Id>1520815340648</Id>
					<Name><![CDATA[extract]]></Name>
					<Description><![CDATA[Takes a population, identifies the desired subpopulations, and then returns a means of repeatedly gathering that statistic for each subpopulation, mapping them to combinations of the given objects. The subpopulations may overlap, and they do not need to cover the total population. This is useful for generating graphs that require statistics on a textured population.

The population is provided via a supplier

For example, population -> group by SES quintiles -> get disease statistics.
For example, population -> get all women, get all mothers, get all women who are not mothers  -> get depression statistics

@pre no argument null]]></Description>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>450</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Supplier<Iterable<T>>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[transform]]></Name>
						<Type><![CDATA[Function<List<T>,U>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[dimensions]]></Name>
						<Type><![CDATA[List<List<Object>>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[groupGenerator]]></Name>
						<Type><![CDATA[BiPredicate<List<Object>, T>]]></Type>
					</Parameter>
					<Body><![CDATA[// Sanity check.
assertNotNull("Population supplier not provided.", things);
assertNotNull("Statistic  generator not provided.", transform);
assertNotNull("At least one group needs to be provided.", groups != null &&  groups.size() > 0);

// Create groups.
for (int i = 0; i < dimensions; i += 1) {
}

// Extract each group.
Supplier<Map<V, U>> ongoingResult = () -> {
	Map<V,U> result = new HashMap<>();
	Iterable<T> concreteThings = things.get();
	groups
		.parallelStream()
		.map(group -> 
			new Pair<Grouping<List<Object>, T>, U>(
				group,
				transform.apply(
					StreamSupport
						.stream(concreteThings.spliterator(), true)
						.filter(next -> group.isMember(next))
						.collect(Collectors.toList())
				)
			)
		)
		.sequential()
		.forEach(pair -> result.put(pair.getFirst().getIdentifier(), pair.getSecond()))
	;
	return result;
};

// Return the result.
return ongoingResult;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> double]]></ReturnType>
					<Id>1520815340650</Id>
					<Name><![CDATA[parallelAverage]]></Name>
					<Description><![CDATA[Returns an average that is safe for use in charts / SD diagrams, i.e., if the average is NAN a default value is returned.]]></Description>
					<X>30</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[things]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[value]]></Name>
						<Type><![CDATA[ToDoubleFunction<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[nanValue]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[Double avg = StreamSupport.stream(things.spliterator(), true)
	.mapToDouble(value)
	.average()
	.orElse(nanValue)
;

if (avg.isNaN())
	return nanValue;
else
	return avg;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340652</Id>
					<Name><![CDATA[interpolate]]></Name>
					<Description><![CDATA[Performs a linear interpolation.

@pre fraction in range [0, 1]]]></Description>
					<X>30</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[start]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[finish]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fraction]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[// Sanity check.
if (!(0 <= fraction && fraction <= 1))
	fail("Fraction ("+fraction+") must be in range [0,1].");

double gap = finish - start;
return start + gap * fraction;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T, U> List<U>]]></ReturnType>
					<Id>1520815340654</Id>
					<Name><![CDATA[parallelMapCollectToList]]></Name>
					<Description><![CDATA[Returns a mapping of the given population. The operation is parallelized, which may result in speed improvements for large populations.

@remarks
This function originated from the need to extract things like parents of children matching some criteria, people with dementia whose carers earned a certain income, etc.]]></Description>
					<X>190</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[Iterable<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[mapper]]></Name>
						<Type><![CDATA[Function<T, U>]]></Type>
					</Parameter>
					<Body><![CDATA[return StreamSupport.stream(population.spliterator(), true)
	.map(mapper)
	.collect(Collectors.toList())
;]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520815340656</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>



		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815340663</Id>
			<Name><![CDATA[ValueTracker]]></Name>
			<Description><![CDATA[An agent that allows you to track the value a model is producing versus the value it should be producing. The utility of this class comes largely from its percent error functionality: by defining how close you need the model to be to the "real" value, you can ensure and assert in tests and visually that the model is behaving good enough for your purposes.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import java.util.function.Supplier;
import java.util.function.Function;
import ca.loif.niceassert.NiceAssert;]]></Import>
			<StartupCode><![CDATA[// If we're to show the actual values, do so.
if (startWithValuesShown)
	chkShowActualValues.setSelected(true, true);]]></StartupCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520815340658</Id>
				<Name><![CDATA[1520815340658]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1485936000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815340659</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815340752</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1520815340710</Id>
					<Name><![CDATA[percentErrorData]]></Name>
					<Description><![CDATA[The percent error data updated as the simulation runs. This is an extended data set as it allows some statistics to be calculated more easily.]]></Description>
					<X>-260</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="false">
						<Type><![CDATA[ExtendedDataSet]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ExtendedDataSet(10_000, 0)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1520815340712</Id>
					<Name><![CDATA[modelValueData]]></Name>
					<Description><![CDATA[The actual value updated as the simulation runs. This is an extended data set as it allows some statistics to be calculated more easily.]]></Description>
					<X>-260</X><Y>260</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="false">
						<Type><![CDATA[ExtendedDataSet]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ExtendedDataSet(10_000, 0)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1520815340714</Id>
					<Name><![CDATA[expectedValueData]]></Name>
					<Description><![CDATA[The expected value updated as the simulation runs. This is an extended data set as it allows some statistics to be calculated more easily.]]></Description>
					<X>-260</X><Y>280</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="false">
						<Type><![CDATA[ExtendedDataSet]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ExtendedDataSet(10_000, 0)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1520815340716</Id>
					<Name><![CDATA[errorPlotLine]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>-260</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[ChartItem]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340732</Id>
					<Name><![CDATA[thresholdPercent]]></Name>
					<X>-260</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[double]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[10.0]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340730</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340735</Id>
					<Name><![CDATA[expectedValueLabel]]></Name>
					<X>-260</X><Y>420</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA["Expected"]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340733</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340738</Id>
					<Name><![CDATA[expectedValueGivenCurrentModelTime]]></Name>
					<X>-260</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Function<Double, Double>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[time -> 0d]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340736</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340741</Id>
					<Name><![CDATA[modelValueLabel]]></Name>
					<X>-260</X><Y>400</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA["Model"]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340739</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340744</Id>
					<Name><![CDATA[actualValueGivenCurrentModelTime]]></Name>
					<X>-260</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Function<Double, Double>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[time -> 0d]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340742</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340747</Id>
					<Name><![CDATA[startWithValuesShown]]></Name>
					<X>-260</X><Y>340</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[false]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340745</Id>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1520815340750</Id>
					<Name><![CDATA[updateTimeInMonths]]></Name>
					<X>-240</X><Y>510</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[double]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1520815340748</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Events>
				<Event>
					<Id>1520815340729</Id>
					<Name><![CDATA[autoUpdate]]></Name>
					<X>-260</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="cyclic">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_YEAR]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1497945600000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[updateTimeInMonths]]></Code>
							<Unit Class="TimeUnits"><![CDATA[MONTH]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[update();]]></Action>
				</Event>
			</Events>
			<Functions>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340680</Id>
					<Name><![CDATA[percentError]]></Name>
					<X>-260</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[actual]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[expected]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[return zidz(abs(actual - expected), abs(expected)) * 100;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340682</Id>
					<Name><![CDATA[update]]></Name>
					<X>-240</X><Y>530</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[// Update the chart.
double actual = actualValueGivenCurrentModelTime.apply(time());
double expected = expectedValueGivenCurrentModelTime.apply(time());
percentErrorData.add(
	time(),
	percentError(actual, expected)
);
modelValueData.add(
	time(),
	actual
);
expectedValueData.add(
	time(),
	expected
);

// Update labels.
txtActual.setText(modelValueLabel+": " +  format(actual));
txtExpected.setText(expectedValueLabel+": " + format(expected));

// Remove the data items from the chart so we can re-add them with better color.
if (chkShowErrorLine.isSelected()) {
	errorChart.remove(percentErrorData);

	// What's our percent error?
	//double indicatorPercentError = percentErrorData.getY(percentErrorData.size()-1);

	// If the error is out of bounds, highlight red.
	final String Label = "% Error";
	Color color = slateGray;
	//traceln("Indicator: " + indicatorPercentError + "; thresh = " + thresholdPercent);
	if (isExceedingErrorThreshold()) {
		color = red;
	}
	ExperimentUtilities.plot(Label, color, percentErrorData, errorChart);
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340684</Id>
					<Name><![CDATA[getValue]]></Name>
					<Description><![CDATA[Returns the actual value of the calculated statistic (i.e., not the expected statistic).]]></Description>
					<X>-160</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return actualValueGivenCurrentModelTime.apply(time());]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340686</Id>
					<Name><![CDATA[getMedianPercentError]]></Name>
					<Description><![CDATA[Gets the median percent error using existing data.]]></Description>
					<X>-260</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return percentErrorData.getYMedian();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340688</Id>
					<Name><![CDATA[getMedianPercentErrorBetween]]></Name>
					<Description><![CDATA[Gets the median percent error using existing data.]]></Description>
					<X>-260</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[timeStart]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[timeEnd]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[return percentErrorData.between(timeStart, timeEnd).getYMedian();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ExtendedDataSet]]></ReturnType>
					<Id>1520815340690</Id>
					<Name><![CDATA[getActualValueData]]></Name>
					<Description><![CDATA[@return
	The actual values of the variable being monitored.]]></Description>
					<X>-260</X><Y>560</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[// Initialize the dataset if needed and then return.
//if (actualValueData == null)
//	actualValueData = new ExtendedDataSet(10_000, 0);
return modelValueData;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ExtendedDataSet]]></ReturnType>
					<Id>1520815340692</Id>
					<Name><![CDATA[getExpectedValueData]]></Name>
					<Description><![CDATA[@return
	The expected values of the variable being monitored.]]></Description>
					<X>-260</X><Y>580</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[// Initialize the dataset if needed and then return.
//if (expectedValueData == null)
//	expectedValueData = new ExtendedDataSet(10_000, 0);
return expectedValueData;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[boolean]]></ReturnType>
					<Id>1520815340694</Id>
					<Name><![CDATA[isExceedingErrorThreshold]]></Name>
					<Description><![CDATA[@return
	True, if the current model value is different to the expected value by greater than the error threshold, false otherwise.]]></Description>
					<X>-260</X><Y>600</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[/*// We can't be exceeding the threshold if there is no data.
if (percentErrorData.size() == 0)
	return false;

// What's our percent error?
double indicatorPercentError = percentErrorData.getY(percentErrorData.size()-1);

// Is it in a bad spot?
return indicatorPercentError > thresholdPercent;*/

return getCurrentPercentError() > thresholdPercent;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1520815340696</Id>
					<Name><![CDATA[toString]]></Name>
					<X>-260</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[double expectedValue = getExpectedValue();
double modelValue = getValue();
return "Model: " + format(modelValue) + ", Expected: " + format(expectedValue) + ", % Error: " + format(getCurrentPercentError());]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340698</Id>
					<Name><![CDATA[getExpectedValue]]></Name>
					<Description><![CDATA[Returns the actual value of the calculated statistic (i.e., not the expected statistic).]]></Description>
					<X>-160</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return expectedValueGivenCurrentModelTime.apply(time());]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340700</Id>
					<Name><![CDATA[assertWithinThreshold]]></Name>
					<Description><![CDATA[Tests whether or not the tracked value is within the error threshold with a value sampled right now, throwing an exception if it is not.]]></Description>
					<X>-260</X><Y>720</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[errorMessagePrefix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[NiceAssert.assertFalse(
	errorMessagePrefix + " (expected: "+format(getExpectedValue())+", model: "+format(getValue())+", % error: "+format(getCurrentPercentError())+", threshold: "+thresholdPercent+")",
	isExceedingErrorThreshold()
);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340702</Id>
					<Name><![CDATA[getCurrentPercentError]]></Name>
					<Description><![CDATA[Returns the current percent error between the expected value and the model-produced value.]]></Description>
					<X>-160</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[double expectedValue = getExpectedValue();
double modelValue = getValue();
return percentError(modelValue, expectedValue);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340704</Id>
					<Name><![CDATA[percentErrorFrom]]></Name>
					<Description><![CDATA[Returns the percent error from the current value and the given value. This function is useful when figuring out hte percent error from an expected value under intervention conditions, for example.]]></Description>
					<X>-260</X><Y>700</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[expected]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[return percentError(getValue(), expected);
	]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340706</Id>
					<Name><![CDATA[assertWithinThresholdOfValue]]></Name>
					<Description><![CDATA[Tests whether or not the tracked value is within the error threshold with a value sampled right now, throwing an exception if it is not.]]></Description>
					<X>-260</X><Y>770</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[value]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[errorMessagePrefix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[NiceAssert.assertFalse(
	errorMessagePrefix + " (expected: "+format(value)+", model: "+format(getValue())+", % error from provided value: "+format(percentErrorFrom(value))+", threshold: "+thresholdPercent+")",
	percentErrorFrom(value) > thresholdPercent
);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815340708</Id>
					<Name><![CDATA[assertMedianWithinThreshold]]></Name>
					<Description><![CDATA[Tests whether or not the median of the tracked value  is within the error threshold, throwing an exception if it is not.

@param timStart
The start of the time period of measurement.
@param timeEnd
The end of the time period of measurement.]]></Description>
					<X>-260</X><Y>740</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[timeStart]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[timeEnd]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[errorMessagePrefix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[
NiceAssert.assertFalse(
	errorMessagePrefix + 
	" (expected median: "+format(getExpectedValueData().between(timeStart, timeEnd).getYMedian())+
	", model median: "+format(getActualValueData().between(timeStart, timeEnd).getYMedian())+
	", median % error: "+format(getMedianPercentErrorBetween(timeStart, timeEnd))+
	", threshold: "+thresholdPercent +
	", model values (sample): "+getActualValueData().between(timeStart, timeEnd).stream().map(kvp -> "" + format(kvp.getValue()) + ", ").limit(10).reduce(String::concat)+
	", time: ["+timeStart+","+timeEnd+"]"+")",
	getMedianPercentErrorBetween(timeStart, timeEnd) > thresholdPercent
);]]></Body>
				</Function>
			</Functions>
			<AnalysisData>
    			<DataSet>
					<Id>1520815340666</Id>
					<Name><![CDATA[percentErrorDataxxx]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>-260</X><Y>140</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1485936000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>true</FreezeXAxis>
					<VerticalAxisExpression><![CDATA[percentError(
	actualValueGivenCurrentModelTime.apply(time()),
	expectedValueGivenCurrentModelTime.apply(time())
)]]></VerticalAxisExpression>
					<SamplesToKeep>10000</SamplesToKeep>
				</DataSet>
			</AnalysisData>
			<AgentLinks>
				<AgentLink>
					<Id>1520815340752</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Shapes>
				<Rectangle>
					<Id>1520815340718</Id>
					<Name><![CDATA[rectangle]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<Width>260</Width>
					<Height>280</Height>
					<Rotation>0.0</Rotation>
					<FillColor>-1</FillColor>
					<FillMaterial>null</FillMaterial>
				</Rectangle>
				<Text>
					<Id>1520815340720</Id>
					<Name><![CDATA[txtActual]]></Name>
					<X>65</X><Y>200</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Actual: xxx]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1520815340722</Id>
					<Name><![CDATA[txtExpected]]></Name>
					<X>65</X><Y>215</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Expected: xxx]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Rectangle>
					<Id>1520815340724</Id>
					<Name><![CDATA[chartFrame]]></Name>
					<X>10</X><Y>20</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>false</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<Width>240</Width>
					<Height>210</Height>
					<Rotation>0.0</Rotation>
					<FillColor>-1</FillColor>
					<FillMaterial>null</FillMaterial>
				</Rectangle>
				<Text>
					<Id>1520815340726</Id>
					<Name><![CDATA[chartText]]></Name>
					<X>110</X><Y>110</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>false</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>315.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Chart]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>CENTER</Alignment>
				</Text>
			</Shapes>
			<Controls>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1520815340676</Id>
					<Name><![CDATA[chkShowActualValues]]></Name>
					<X>50</X><Y>230</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="180" Height="30">
                        <EmbeddedIcon>false</EmbeddedIcon>	
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[if (value == true) {
	ExperimentUtilities.plot(
		modelValueLabel, 
		dodgerBlue, 
		modelValueData, 
		errorChart
	);
	ExperimentUtilities.plot(
		expectedValueLabel, 
		new Color(0, 0, 255, 100), 
		expectedValueData, 
		errorChart
	);
}
else {
	errorChart.remove(modelValueData);
	errorChart.remove(expectedValueData);
}]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Show Real Values]]></LabelText>
						<DefaultValueCode><![CDATA[false]]></DefaultValueCode>
						<LinkTo>false</LinkTo>
	 				</ExtendedProperties>
				</Control>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1520815340678</Id>
					<Name><![CDATA[chkShowErrorLine]]></Name>
					<X>50</X><Y>250</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="180" Height="30">
                        <EmbeddedIcon>false</EmbeddedIcon>	
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[// Remove the data items from the chart so we can re-add them with better color.
errorChart.remove(percentErrorData);

// If we're to show the error line, add it.
if (value == true) {


	// What's our percent error?
	double indicatorPercentError = percentErrorData.getY(percentErrorData.size()-1);
	
	// If the error is out of bounds, highlight red.
	final String Label = "% Error";
	Color color = slateGray;
	//traceln("Indicator: " + indicatorPercentError + "; thresh = " + thresholdPercent);
	if (indicatorPercentError > thresholdPercent) {
		color = red;
	}
	ExperimentUtilities.plot(Label, color, percentErrorData, errorChart);

}]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Show Percent Error]]></LabelText>
						<DefaultValueCode><![CDATA[true]]></DefaultValueCode>
						<LinkTo>false</LinkTo>
	 				</ExtendedProperties>
				</Control>
			</Controls>
			<Charts>
    			<TimeStackChart>
					<Id>1520815340670</Id>
					<Name><![CDATA[errorChartOld]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>220</X><Y>-230</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1485936000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>260</Width>
					<Height>210</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>180</Width>
						<Height>120</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<TimeWindowsMovementType>MOVEMENT_WITH_TIME</TimeWindowsMovementType>		
					<TimeWindowUnits>MODEL_TIME_UNIT</TimeWindowUnits>
					<TimeWindowExpression><![CDATA[100]]></TimeWindowExpression>
					<DatasetExpression>
					<Expression><![CDATA[percentErrorDataxxx]]></Expression>
					<Color>-931102592</Color>
					<Expression2><![CDATA[percentError(
	actualValueGivenCurrentModelTime.apply(time()),
	expectedValueGivenCurrentModelTime.apply(time())
);]]></Expression2>
					<Expression2Flag>false</Expression2Flag>  
							<Title><![CDATA[% Error]]></Title>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<LabelFormat>MODEL_TIME_UNITS</LabelFormat>
    			</TimeStackChart>
    			<Plot>
					<Id>1520815340674</Id>
					<Name><![CDATA[errorChart]]></Name>
					<X>10</X><Y>0</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1488182400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>260</Width>
					<Height>200</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>180</Width>
						<Height>100</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>40</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[% Error]]></Title>
					<Expression><![CDATA[percentErrorData]]></Expression>
					<Color>-8355712</Color>
					<Expression2><![CDATA[0]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>3.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[0]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
			</Charts>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815555030</Id>
			<Name><![CDATA[Main]]></Name>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520815555029</Id>
				<Name><![CDATA[1520815555029]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1520841600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815555027</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815555026</ConnectionsId>
			<AgentLinks>
				<AgentLink>
					<Id>1520815555026</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>



		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520815724185</Id>
			<Name><![CDATA[DataSetUtilities]]></Name>
			<Description><![CDATA[Useful functions for managing DataSets.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import java.util.function.*;
import java.util.stream.Collectors;
import java.util.function.BiConsumer;]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520815724180</Id>
				<Name><![CDATA[1520815724180]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1486368000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520815724181</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520815724201</ConnectionsId>
			<Functions>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Map<Double, Double>]]></ReturnType>
					<Id>1520815724187</Id>
					<Name><![CDATA[mapData]]></Name>
					<Description><![CDATA[Creates a map from a data set for easier manipulation.]]></Description>
					<X>30</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[data]]></Name>
						<Type><![CDATA[DataSet]]></Type>
					</Parameter>
					<Body><![CDATA[Map<Double, Double> map = new HashMap<>();
for (int i = 0; i < data.size(); i += 1)
	map.put(data.getX(i), data.getY(i));
return map;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[DataSet]]></ReturnType>
					<Id>1520815724189</Id>
					<Name><![CDATA[subset]]></Name>
					<Description><![CDATA[Returns a subset of the dataset copied to a new dataset object.

@param dataSet
	The dataset.
@param whereXY
	A predicated determining whether an (x,y) pair is to go into the new dataset.]]></Description>
					<X>30</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[dataSet]]></Name>
						<Type><![CDATA[DataSet]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[whereXY]]></Name>
						<Type><![CDATA[BiPredicate<Double,Double>]]></Type>
					</Parameter>
					<Body><![CDATA[List<Map.Entry<Double,Double>> xyPairs = mapData(dataSet)
	.entrySet()
	.stream()
	.filter(xy -> whereXY.test(xy.getKey(), xy.getValue()))
	.collect(Collectors.toList())
;

DataSet toReturn = new DataSet(xyPairs.size());
xyPairs.forEach(xy -> toReturn.add(xy.getKey(), xy.getValue()));
return toReturn;
]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[DataSet]]></ReturnType>
					<Id>1520815724191</Id>
					<Name><![CDATA[createDataSet]]></Name>
					<Description><![CDATA[Creates a data set from two arrays. Used primarily to create reference lines in charts.

@pre xValues length == yValues length]]></Description>
					<X>30</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[xValues]]></Name>
						<Type><![CDATA[double[]]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[yValues]]></Name>
						<Type><![CDATA[double[]]]></Type>
					</Parameter>
					<Body><![CDATA[// Sanity check
if (xValues.length != yValues.length) 
	throw new Error("X and Y value arrays must have the same length. "+xValues.length+" vs "+yValues.length);
	
// Create the dataset.
DataSet ds = new DataSet(xValues.length);
for (int i = 0; i < xValues.length; i += 1) {
	ds.add(xValues[i], yValues[i]);
}
return ds;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[TableFunction]]></ReturnType>
					<Id>1520815724193</Id>
					<Name><![CDATA[convertToTableFunction]]></Name>
					<Description><![CDATA[Converts the data set into a table function.]]></Description>
					<X>30</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[dataset]]></Name>
						<Type><![CDATA[DataSet]]></Type>
					</Parameter>
					<Body><![CDATA[double[] arguments = new double[dataset.size()];
double[] values = new double[dataset.size()];

// Accumulate values for the table function. 
for (int i = 0; i < dataset.size(); i += 1) {
	arguments[i] = dataset.getX(i);
	values[i] = dataset.getY(i);
}

// Create the table function.
return new TableFunction(
	arguments,
	values,
	TableFunction.InterpolationType.INTERPOLATION_LINEAR, 
	1, // Not applicable.
	TableFunction.OutOfRangeAction.OUTOFRANGE_EXTRAPOLATE,
	Double.NaN
);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[DataSet]]></ReturnType>
					<Id>1520815724195</Id>
					<Name><![CDATA[createDataSet]]></Name>
					<Description><![CDATA[Creates a data set from a known set of X values and a formula that determines how those X values are mapped to a Y value. Used primarily to create reference lines in charts.]]></Description>
					<X>30</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[xValues]]></Name>
						<Type><![CDATA[double[]]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[yValueSupplier]]></Name>
						<Type><![CDATA[Function<Double, Double>]]></Type>
					</Parameter>
					<Body><![CDATA[// Create the dataset.
DataSet ds = new DataSet(xValues.length);
for (int i = 0; i < xValues.length; i += 1) {
	ds.add(xValues[i], yValueSupplier.apply(xValues[i]));
}
return ds;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520815724197</Id>
					<Name><![CDATA[forEach]]></Name>
					<Description><![CDATA[Iterates over the items in the data set.]]></Description>
					<X>30</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[ds]]></Name>
						<Type><![CDATA[DataSet]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[action]]></Name>
						<Type><![CDATA[BiConsumer<Double, Double>]]></Type>
					</Parameter>
					<Body><![CDATA[for (int i = 0; i < ds.size(); i += 1) {
	action.accept(ds.getX(i), ds.getY(i));
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1520815724199</Id>
					<Name><![CDATA[prettyString]]></Name>
					<Description><![CDATA[Converts a table function into a list of (argument, value)s.]]></Description>
					<X>30</X><Y>170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[input]]></Name>
						<Type><![CDATA[TableFunction]]></Type>
					</Parameter>
					<Body><![CDATA[StringBuilder sb = new StringBuilder();
sb.append("[Interpolation: ").append(input.getInterpolationType().toString()).append("; Values: ");

for (int i = 0; i < input.getLength(); i += 1) {

	sb.append("(").append(input.getArguments()[i]+","+input.getValues()[i]+")");
	
	// Put a comma after everything but the last element.
	if (i != input.getLength() - 1)
		sb.append(", ");

}

sb.append("]");

// Done!
return sb.toString();]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520815724201</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>



		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1520816771491</Id>
			<Name><![CDATA[MonetaryUtilities]]></Name>
			<Description><![CDATA[Useful functions when dealing with monetary figures and large numbers.

NOTICE
Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1520816771486</Id>
				<Name><![CDATA[1520816771486]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1520841600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1520816771487</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1520816771499</ConnectionsId>
			<Functions>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520816771493</Id>
					<Name><![CDATA[million]]></Name>
					<Description><![CDATA[Multiply by an amount to get that many millions. E.g., 3 * billion().]]></Description>
					<X>40</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return 1_000_000.0;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520816771495</Id>
					<Name><![CDATA[billion]]></Name>
					<Description><![CDATA[Multiply by an amount to get that many billions. E.g., 3 * billion().]]></Description>
					<X>40</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return 1_000_000_000.0;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1520816771497</Id>
					<Name><![CDATA[thousand]]></Name>
					<Description><![CDATA[Multiply by an amount to get that many thousands. E.g., 3 * billion().]]></Description>
					<X>40</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return 1_000.0;]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1520816771499</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>



		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1537484329185</Id>
			<Name><![CDATA[CitationTracker]]></Name>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import de.undercouch.citeproc.csl.*;
import de.undercouch.citeproc.csl.CSLItemDataBuilder;
import de.undercouch.citeproc.CSL;
import de.undercouch.citeproc.output.Bibliography;
import de.undercouch.citeproc.helper.json.StringJsonBuilder;
import static ca.anthrodynamics.toolkit.anylogic.CollectionUtilities.*;
import java.util.function.Function;
import java.util.stream.Collectors;

import java.io.File;
import java.io.FileOutputStream;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFTable;
import org.apache.poi.xwpf.usermodel.XWPFTableRow;
]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1537484329180</Id>
				<Name><![CDATA[1537484329180]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1489996800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[YEAR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1537484329181</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1537484329207</ConnectionsId>
			<Variables>
				<Variable Class="CollectionVariable">
					<Id>1537484329187</Id>
					<Name><![CDATA[citedValues]]></Name>
					<Description><![CDATA[Values cited in the model.]]></Description>
					<X>20</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="private" StaticVariable="true">
						<CollectionClass><![CDATA[LinkedHashMap]]></CollectionClass>
						<ElementClass><![CDATA[LinkedHashSet<CSLItemDataBuilder>]]></ElementClass>
						<ValueElementClass><![CDATA[Object]]></ValueElementClass>
					</Properties>

				</Variable>
			</Variables>
			<Functions>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[<T> T]]></ReturnType>
					<Id>1537484329189</Id>
					<Name><![CDATA[use]]></Name>
					<Description><![CDATA[Registers the citation and logs the value.]]></Description>
					<X>20</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[value]]></Name>
						<Type><![CDATA[T]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[primaryCitation]]></Name>
						<Type><![CDATA[CSLItemDataBuilder]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[citations]]></Name>
						<Type><![CDATA[CSLItemDataBuilder...]]></Type>
					</Parameter>
					<Body><![CDATA[LinkedHashSet<CSLItemDataBuilder> sources = new LinkedHashSet<>();
sources.add(primaryCitation);//.build());
for (int i = 0; i < citations.length; i += 1)
	sources.add(citations[i]);//.build());

if (!citedValues.containsKey(sources) || citedValues.get(sources) != value)
	citedValues.put(sources, value);

return value;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ModelCitation]]></ReturnType>
					<Id>1537484329191</Id>
					<Name><![CDATA[citation]]></Name>
					<Description><![CDATA[Convenience method to get a citation builder more quickly.]]></Description>
					<X>20</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[ModelCitation citation = new ModelCitation(
	label,
	Thread.currentThread().getStackTrace()[2].getClassName()
);
return citation;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1537484329193</Id>
					<Name><![CDATA[dumpBibliography]]></Name>
					<X>20</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[format]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[CSLItemData[] data = new CSLItemData[citedValues.size()];
int i = 0;
for (CSLItemData next : citedValues.keySet().stream().flatMap(c -> c.stream()).map(raw -> raw.build()).collect(Collectors.toList())) {
	data[i] = next;
	i += 1;
}
try {
	traceln(CSL.makeAdhocBibliography(format, data).makeString());
}
catch (Throwable t) {
	throw new RuntimeException(t);
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1537484329195</Id>
					<Name><![CDATA[dumpSimpleBibliography]]></Name>
					<Description><![CDATA[Dumps a simple bibliography to the console.]]></Description>
					<X>20</X><Y>170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[// Build the header
final String Sep = "\t";
StringBuilder header = new StringBuilder();
list(
	"Label",
	"Value",
	"Notes",
	"Authority",
	"Primary Document",
	"Authors",
	"Date",
	"DOI",
	"URL",
	"Accessed",
	"Class in Model Setting this Field"
).forEach(
	item -> header.append(item).append(Sep)
);
traceln(header.toString());

// Dump the values.
citedValues
	.entrySet()
	.stream()
	.sorted((A,B) -> A.getKey().iterator().next().build().getCitationLabel().compareTo(B.getKey().iterator().next().build().getCitationLabel()))
	.forEach(kvp -> {
		int subCitationNumber = 1;
		for (CSLItemDataBuilder rawCitation : kvp.getKey()) {
			CSLItemData citation = rawCitation.build();
			Object value = kvp.getValue();
			
			String authorString = "";
			if (citation.getAuthor() != null) {
				for (CSLName name : Arrays.asList(citation.getAuthor())) { 
					authorString += name.getFamily() + ", " + name.getGiven() + "; ";
				}
			}
			else {
				authorString = null;
			}
			
			// Special data type strings that frequently appear.
			String valueString = value.toString();
			if (value instanceof TableFunction) {
				TableFunction tf = (TableFunction)value;
				Map<Double, Double> table = new TreeMap<>();
				for (int i = 0; i < tf.getValues().length; i += 1) {
					table.put(tf.getArguments()[i], tf.getValues()[i]);
				}
				valueString = "Table Function [" + table + ", " + tf.getInterpolationType() + ", " + tf.getOutOfRangeAction()+"]";	
			}
			else if (value instanceof CustomDistribution || value instanceof CustomDistributionOfOptions) {
				
				// TODO: VERY crude. Close enough for now. Isn't behaving, have other things to do today.
				String rawString = value.toString();
				String truncatedString = rawString
					.replaceAll("[\\n\\r]+", ",")
					.replaceAll("\t","=")
					.replace(".*rows?,(.*)", "\1")
				;
				
				valueString = "Distribution [" + truncatedString + "]";	
			}
			else if (value.getClass().isArray()) {
				valueString = CollectionUtilities.deepToString(value);
			}
			
			StringBuilder sb = new StringBuilder();
			list(
				citation.getCitationLabel(),
				valueString,
				citation.getNote(),
				//subCitationNumber,
				citation.getAuthority(),
				citation.getTitle(),
				authorString,
				ifNotNull(citation.getOriginalDate(), c -> Arrays.deepToString(c.getDateParts())),
				citation.getDOI(),
				citation.getURL(),
				ifNotNull(citation.getAccessed(), c -> Arrays.deepToString(c.getDateParts()))
			).forEach(
				item -> sb.append(item).append(Sep)
			);
			
			if (rawCitation instanceof ModelCitation)
				sb.append(((ModelCitation)rawCitation).creatingClazz).append(Sep);
			else
				sb.append("null").append(Sep);
			
			traceln(sb.toString());
			
			subCitationNumber += 1;
		}
	})
;
]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1537484329197</Id>
					<Name><![CDATA[clear]]></Name>
					<Description><![CDATA[Clears all citations.]]></Description>
					<X>20</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[citedValues.clear();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[CSLName]]></ReturnType>
					<Id>1537484329199</Id>
					<Name><![CDATA[name]]></Name>
					<Description><![CDATA[Convenience method for producing a CSL name.]]></Description>
					<X>20</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[family]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[given]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[return new CSLName(
               family, //String family,
               given, //String given,
               null,  //String droppingParticle,
               null,  //String nonDroppingParticle,
               null,  //String suffix,
               false, //Boolean commaPrefix,
               false, //Boolean commaSuffix,
               false, //Boolean staticOrdering,
               false, //Boolean staticParticles,
               null,  //String literal,
               false, //Boolean parseNames,
               false  //Boolean isInstitution
);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ModelCitation]]></ReturnType>
					<Id>1537484329201</Id>
					<Name><![CDATA[placeholder]]></Name>
					<Description><![CDATA[Convenience method to get a citation builder more quickly.]]></Description>
					<X>40</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[// Need to log class name here, otherwise this method will show up as the calling class which isn't what we want.
return (ModelCitation)(citation("Placeholder: " + label, Thread.currentThread().getStackTrace()[2].getClassName())).authority("Modeler");]]></Body>
				</Function>
				<Function AccessType="private" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ModelCitation]]></ReturnType>
					<Id>1537484329203</Id>
					<Name><![CDATA[citation]]></Name>
					<Description><![CDATA[Convenience method to get a citation builder more quickly.]]></Description>
					<X>40</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[label]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[className]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[ModelCitation citation = new ModelCitation(
	label,
	className
);
return citation;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1537484329205</Id>
					<Name><![CDATA[dumpBibliographyToWord]]></Name>
					<X>20</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[// Graciously derived from https://www.tutorialspoint.com/apache_poi_word/apache_poi_word_tables.htm
//Blank Document
try {
	XWPFDocument document = new XWPFDocument();
	
	//Write the Document in file system
	FileOutputStream out = new FileOutputStream(new File("references.docx"));
	
	//create table
	XWPFTable table = document.createTable();
	
	// Create the header.
	XWPFTableRow headerRow = table.getRow(0);
	final int LabelCell = 0, 
		ValueCell = 1,
		DocumentDataCell = 2
	;
	headerRow.getCell(0).setText("Label");
	headerRow.addNewTableCell().setText("Value");
	headerRow.addNewTableCell().setText("Source and Notes");
		
	// Dump the values.
	citedValues
		.entrySet()
		.stream()
		.sorted((A,B) -> A.getKey().iterator().next().build().getCitationLabel().compareTo(B.getKey().iterator().next().build().getCitationLabel()))
		.forEach(kvp -> {
			int subCitationNumber = 1;
			for (CSLItemDataBuilder rawCitation : kvp.getKey()) {
				CSLItemData citation = rawCitation.build();
				Object value = kvp.getValue();
				
				String authorString = "";
				if (citation.getAuthor() != null) {
					for (CSLName name : Arrays.asList(citation.getAuthor())) { 
						authorString += name.getFamily() + ", " + name.getGiven() + "; ";
					}
				}
				else {
					authorString = null;
				}
				
				// Special data type strings that frequently appear.
				String valueString = value.toString();
				if (value instanceof TableFunction) {
					TableFunction tf = (TableFunction)value;
					Map<Double, Double> tableFunction = new TreeMap<>();
					for (int i = 0; i < tf.getValues().length; i += 1) {
						tableFunction.put(tf.getArguments()[i], tf.getValues()[i]);
					}
					valueString = "Table Function [" + tableFunction + ", " + tf.getInterpolationType() + ", " + tf.getOutOfRangeAction()+"]";	
				}
				else if (value instanceof CustomDistribution || value instanceof CustomDistributionOfOptions) {
					
					// TODO: VERY crude. Close enough for now. Isn't behaving, have other things to do today.
					String rawString = value.toString();
					String truncatedString = rawString
						.replaceAll("[\\n\\r]+", ",")
						.replaceAll("\t","=")
						.replace(".*rows?,(.*)", "\1")
					;
					
					valueString = "Distribution [" + truncatedString + "]";	
				}
				else if (value.getClass().isArray()) {
					valueString = CollectionUtilities.deepToString(value);
				}
				
				// Create the row.
				XWPFTableRow row = table.createRow();
				String citationLabel = citation.getCitationLabel();
				if (subCitationNumber > 1)
					citationLabel = "(Continuation of preceding item) " + citationLabel;
				row.getCell(LabelCell).setText(citationLabel);
				row.getCell(ValueCell).setText(valueString);
				
				// Authors / authority a bit funny.
				String authorityString = citation.getAuthority();
				StringBuilder sourceSb = new StringBuilder();
				final String SEP = ". ";
				if (authorityString == null && authorString != null)
					sourceSb.append(authorString).append(SEP);
				else if (authorityString != null && authorString == null)
					sourceSb.append(authorityString).append(SEP);
				else if (authorityString != null && authorString != null)
					sourceSb.append(authorityString + " (" + authorString + ")").append(SEP);
				
				// Build up the document string.
				ifNotNull(citation.getTitle(), obj -> sourceSb.append(obj).append(SEP));
				ifNotNull(citation.getOriginalDate(), obj -> {
					String dateString = "";
					if (obj.getDateParts().length == 3)
						dateString = "" + obj.getDateParts()[0][0] + "/" + obj.getDateParts()[0][1] + "/" + obj.getDateParts()[0][2];
					if (obj.getDateParts().length == 2)
						dateString = "" + obj.getDateParts()[0][0] + "/" + obj.getDateParts()[0][1];
					if (obj.getDateParts().length == 1)
						dateString = "" + obj.getDateParts()[0][0];
					
					sourceSb.append(dateString).append(SEP);
					return sourceSb;
				});
				ifNotNull(citation.getDOI(), obj -> sourceSb.append(obj).append(SEP));
				ifNotNull(citation.getURL(), obj -> sourceSb.append(obj).append(SEP));
				ifNotNull(citation.getAccessed(), obj -> {
					String dateString = "Accessed ";
					if (obj.getDateParts().length == 3)
						dateString = "" + obj.getDateParts()[0][0] + "/" + obj.getDateParts()[0][1] + "/" + obj.getDateParts()[0][2];
					if (obj.getDateParts().length == 2)
						dateString = "" + obj.getDateParts()[0][0] + "/" + obj.getDateParts()[0][1];
					if (obj.getDateParts().length == 1)
						dateString = "" + obj.getDateParts()[0][0];
					
					sourceSb.append(dateString).append(SEP);
					return sourceSb;
				});
				ifNotNull(citation.getNote(), obj -> sourceSb.append("Note / See Section: " + obj).append(SEP));
				
				row.getCell(DocumentDataCell).setText(sourceSb.toString());
				subCitationNumber += 1;
			}
		})
	;
		
	// Write out to file.
	document.write(out);
	out.close();
	System.out.println("bibliography docx written successully");
}
catch (Throwable t) {
	throw new RuntimeException(t);
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[ModelCitation]]></ReturnType>
					<Id>1537909436434</Id>
					<Name><![CDATA[referenceDocument]]></Name>
					<Description><![CDATA[Allows a reference document used repeatedly to be cited without having to specify an accompanying value.]]></Description>
					<X>170</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[citation]]></Name>
						<Type><![CDATA[CSLItemDataBuilder]]></Type>
					</Parameter>
					<Body><![CDATA[use(
	"<Reference document>",
	citation
);]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1537484329207</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>



		</ActiveObjectClass>
	</ActiveObjectClasses>	
	<DifferentialEquationsMethod>EULER</DifferentialEquationsMethod>
	<MixedEquationsMethod>RK45_NEWTON</MixedEquationsMethod>
	<AlgebraicEquationsMethod>MODIFIED_NEWTON</AlgebraicEquationsMethod>
	<AbsoluteAccuracy>1.0E-5</AbsoluteAccuracy>
	<FixedTimeStep>0.001</FixedTimeStep>
	<RelativeAccuracy>1.0E-5</RelativeAccuracy>
	<TimeAccuracy>1.0E-5</TimeAccuracy>
	<Frame>
		<Width>1000</Width>
		<Height>600</Height>
	</Frame>
	<Database>
		<Logging>false</Logging>
		<AutoExport>false</AutoExport>
		<ImportSettings>
		</ImportSettings>
		<ExportSettings>
			<ExportExcelFilePath><![CDATA[]]></ExportExcelFilePath>
		</ExportSettings>
	</Database>
	
	<RunConfiguration ActiveObjectClassId="1520815555030">
		<Id>1520815173530</Id>
		<Name><![CDATA[RunConfiguration]]></Name>
		<ModelTimeProperties>
			<StopOption><![CDATA[Stop at specified time]]></StopOption>
			<InitialDate><![CDATA[1520812800000]]></InitialDate>	
			<InitialTime><![CDATA[0.0]]></InitialTime>	
			<FinalDate><![CDATA[1523491200000]]></FinalDate>	
			<FinalTime><![CDATA[100.0]]></FinalTime>	
		</ModelTimeProperties>
		<AnimationProperties>
			<StopNever>true</StopNever>
			<ExecutionMode>realTimeScaled</ExecutionMode>
			<RealTimeScale>1.0</RealTimeScale>
			<EnableZoomAndPanning>true</EnableZoomAndPanning>
			<EnableDeveloperPanel>false</EnableDeveloperPanel>
			<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
		</AnimationProperties>
		<Inputs>		
		</Inputs>
		<Outputs>
		</Outputs>
	</RunConfiguration>
	<JavaClasses>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340753</Id>
			<Name><![CDATA[CachedObject]]></Name>
			<Text><![CDATA[import java.util.function.Supplier;

/**
 * An object to be cached for a set period of time.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public class CachedObject<Type> implements Serializable {
	
	protected double dt = 0;
	protected double lastUpdateTime = Double.NEGATIVE_INFINITY;
	protected Type cachedValue = null;
	protected Supplier<Type> valueSupplier;
	protected Utilities utilities;

	/**
	 * Creates the value.
	 * @param dtInModelTimeUnits
	 * 	The time between cache updates. Cache is only updated when {@link #get()} is called.
	 * @param valueSupplier
	 * 	The function that supplies the value.
	 * 	
	 */
	public CachedObject(Utilities utilities, double dtInModelTimeUnits, Supplier<Type> valueSupplier) {
		this.utilities = utilities;
		this.dt = dtInModelTimeUnits;
		this.valueSupplier = valueSupplier;
	}
	
	/**
	 * Creates the value, using a month as the cache time (this is a common caching time for several models).
	 * @param valueSupplier
	 * 	The function that supplies the value.
	 * 	
	 */
	public CachedObject(Utilities utilities, Supplier<Type> valueSupplier) {
		this(utilities, 1 * utilities.month(), valueSupplier);
	}
	
	/**
	 * Clears the cached value for a fresh retrieval.
	 */
	public synchronized void clear() {
		lastUpdateTime = Double.NEGATIVE_INFINITY;
	}
	
	/**
	 * @return
	 * 	True, if the current value is usable, false if it will be recalculated on the next attempt.
	 */
	public boolean isFresh() {
		return utilities.time() < lastUpdateTime + dt;
	}
	
	/**
	 * @return
	 * 	Gets the value, returning the cached value if necessary.
	 */
	public Type get() {
		
		// If we're clearly fresh, return the 
		if (isFresh())
			return cachedValue;
		
		// Otherwise, update the cached value.
		synchronized(this) {
			// Check again -- has something else updated this? If so, return the cached value.
			if (isFresh())
				return cachedValue;
			
			// Otherwise, recalculate.
			cachedValue = valueSupplier.get();
			lastUpdateTime = utilities.time();
			return cachedValue;
		}
	}
	
	@Override
	public String toString() {
		return get().toString();
	}
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340754</Id>
			<Name><![CDATA[CachedValue]]></Name>
			<Text><![CDATA[import java.util.function.Supplier;

/**
 * A value to put into an SD chart that updates its value only after a certain time period has elapsed.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public class CachedValue extends Number implements Serializable {
	
	private double dt = 0;
	private double lastUpdateTime = Double.NEGATIVE_INFINITY;
	private double cachedValue = Double.NaN;
	private Supplier<Double> valueSupplier;
	private Utilities utilities;

	/**
	 * Creates the value.
	 * @param dtInModelTimeUnits
	 * 	The time between cache updates. Cache is only updated when {@link #get()} is called.
	 * @param valueSupplier
	 * 	The function that supplies the value.
	 * 	
	 */
	public CachedValue(Utilities utilities, double dtInModelTimeUnits, Supplier<Double> valueSupplier) {
		this.utilities = utilities;
		this.dt = dtInModelTimeUnits;
		this.valueSupplier = valueSupplier;
	}
	
	/**
	 * Creates the value, using a month as the cache time (this is a common caching time for several models).
	 * @param valueSupplier
	 * 	The function that supplies the value.
	 * 	
	 */
	public CachedValue(Utilities utilities, Supplier<Double> valueSupplier) {
		this(utilities, 1 * utilities.month(), valueSupplier);
	}
	
	/**
	 * Clears the cached value for a fresh retrieval.
	 */
	public synchronized void clear() {
		lastUpdateTime = Double.NEGATIVE_INFINITY;
	}
	
	/**
	 * @return
	 * 	True, if the current value is usable, false if it will be recalculated on the next attempt.
	 */
	public boolean isFresh() {
		return utilities.time() < lastUpdateTime + dt;
	}
	
	/**
	 * @return
	 * 	Gets the value, returning the cached value if necessary.
	 */
	public double get() {
		
		// If we're clearly fresh, return the 
		if (isFresh())
			return cachedValue;
		
		// Otherwise, update the cached value.
		synchronized(this) {
			// Check again -- has something else updated this? If so, return the cached value.
			if (isFresh())
				return cachedValue;
			
			// Otherwise, recalculate.
			cachedValue = valueSupplier.get();
			lastUpdateTime = utilities.time();
			return cachedValue;
		}
		
		/* // Otherwise, update the cached value.
		lastUpdateTime = utilities.time();
		cachedValue = valueSupplier.get();
		return cachedValue;*/
	}
	
	@Override
	public String toString() {
		return format(cachedValue);
	}
	
	@Override
	public long longValue() {
		return (long)get();
	}
	@Override
	public double doubleValue() {
		return get();
	}
	@Override
	public int intValue() {
		return (int)get();
	}
	@Override
	public float floatValue() {
		return (float)get();
	}
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340755</Id>
			<Name><![CDATA[DeclarativeMapBuilder]]></Name>
			<Text><![CDATA[/**
 * Used to build a map in a declarative fasion.
 * mapOf(
 * 	pair(thing, thing)
 * 	pair(thing, thing)
 * 	pair(thing, thing)
 * )
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public class DeclarativeMapBuilder implements Serializable {

    /**
     * Default constructor
     */
    private DeclarativeMapBuilder() {
    }
    
    /**
     * Creates a map of the given pairs.
     * @pre
     * 	No key used more than once.
     */
    public static <K,V> Map<K,V> mapOf(MapBuilderTuple<K,V>... pairs) {
    	
    	Map<K,V> map = new LinkedHashMap<>();
    	for (int i = 0; i < pairs.length; i += 1) {
    		V old = map.put(pairs[i].key, pairs[i].value);
        	if (old != null)
        		throw new IllegalArgumentException("Duplicate key found. Key: "+pairs[i].key+"; Old Value: "+old+"; New Value: " + pairs[i].value);
    	}
   
    	return map;
    	
    }
    
    public static <K,V> MapBuilderTuple<K, V> pair(K key, V value) {
    	MapBuilderTuple<K, V> t = new MapBuilderTuple<>();
    	t.key = key;
    	t.value = value;
    	return t;
    }
    
    public static class MapBuilderTuple<K, V> {
    	public K key;
    	public V value;
    }

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340756</Id>
			<Name><![CDATA[ExoskeletonOld]]></Name>
			<ExcludeFromBuild>true</ExcludeFromBuild>
			<Text><![CDATA[import static ca.anthrodynamics.toolkit.anylogic.StatisticUtilities.*;
import static ca.anthrodynamics.toolkit.anylogic.CollectionUtilities.*;
import java.util.function.*;
import java.util.stream.*;
import com.google.gson.Gson;

import org.apache.commons.math3.primes.Primes;

/**
 * Provides methods and classes to greatly extend the powers of 
 * regular AnyLogic classes, collections, and common operations.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public class ExoskeletonOld implements Serializable {

    private ExoskeletonOld() {}
    
    /**
     * @return
     * 	An exoskeleton for the collection.
     */
    public static <T, U extends Collection<T>> CollectionExoskeleton<T> $(U collection) {
    	return new CollectionExoskeleton<T>(collection, false);
    }
    
    /**
     * @return
     * 	An exoskeleton for the collection.
     */
    public static <T extends Agent, U extends AgentList<T>> CollectionExoskeleton<T> $(U agents) {
    	return new CollectionExoskeleton<T>(asCollection(agents), false);
    }
    
    /**
     * @return
     * 	An exoskeleton for the items in the cached collection.
     */
    public static <T, U extends CachedObject<? extends Collection<T>>> CollectionExoskeleton<T> $(U cachedCollection) {
    	return new CollectionExoskeleton<T>(cachedCollection.get(), false);
    }
    
    public static Chart1DExoskeleton $(Chart1D chart) {
    	return new Chart1DExoskeletonOld(chart);
    }  
    
    public static PlotExoskeleton $(Chart2DPlot chart) {
    	return new PlotExoskeletonOld(chart);
    }  
    
    public static TimeStackChartExoskeleton $(TimeStackChart chart) {
    	return new TimeStackChartExoskeletonOld(chart);
    }
    
    public static DataSetExoskeleton $(DataSet dataset) {
    	return new DataSetExoskeletonOld(dataset);
    }

    /**
     * Provides easy-access methods for a collection.
     * @author dylan
     *
     * @param <T>
     */
    public static class CollectionExoskeleton<T> {
    	
    	private boolean isParallelized;
    	
    	private Collection<T> collection;
    	
    	public <U extends Collection<T>> CollectionExoskeletonOld(U collection, boolean parallelProcessing) {
    		this.collection = collection;
    		this.isParallelized = parallelProcessing;
    	}
    	
    	/**
    	 * @return
    	 * 	An exoskeleton optimized for parallelization.
    	 */
    	public CollectionExoskeleton<T> inParallel() {
    		return new CollectionExoskeletonOld(collection, true);
    	}
    	
    	public int size() {
    		return collection.size();
    	}
    	
    	/**
    	 * @param predicate
    	 * @return
    	 * 	The percentage of items in the collection matching the predicate.
    	 */
    	public double percentWhere(Predicate<T> predicate) {
    		if (isParallelized)
    			return parallelPercentWhere(collection, predicate);
    		else
    			return StatisticUtilities.percentWhere(collection, predicate);
    	}
    	
    	/**
    	 * @param value
    	 * @return
    	 * 	The sum of the items in the collection.
    	 */
    	public double sum(ToDoubleFunction<T> value) {
    		if (isParallelized)
    			return parallelSum(collection, value);
    		else
    			return collection.stream().mapToDouble(value).sum();
    	}
    	
    	/**
    	 * @param value
    	 * @param nanValue
    	 * 	The value to provide when there are no items to average, or if the average produces NaN.
    	 * @return
    	 * 	The average of the items in the collection.
    	 */
    	public double average(ToDoubleFunction<T> value, double nanValue) {
    		if (isParallelized)
    			return parallelAverage(collection, value, nanValue);
    		else
    			return collection.stream().mapToDouble(value).average().orElse(nanValue);
    	}    	
    	
    	/**
    	 * @param value
    	 * @return
    	 * 	The average of the items in the collection, or NaN if a problem occurs.
    	 */
    	public double average(ToDoubleFunction<T> value) {
    		if (isParallelized)
    			return parallelAverage(collection, value, Double.NaN);
    		else
    			return collection.stream().mapToDouble(value).average().orElse(Double.NaN);
    	}
    	
    	/**
    	 * @return
    	 * 	The number of items matching the criteria.
    	 */
    	public long count(Predicate<T> predicate) {
    		return StreamSupport.stream(collection.spliterator(), isParallelized)
    			.filter(predicate)
    			.count()
    		;
    		/*if (isParallelized)
    			return new CollectionExoskeleton<T>(collection.stream().parallel().filter(predicate).collect(Collectors.toList()), isParallelized);
    		else
    			return new CollectionExoskeleton<T>(collection.stream().filter(predicate).collect(Collectors.toList()), isParallelized);*/
    	}
    	
    	/**
    	 * @return
    	 * 	True, if the collection contains any elements matching the predicate.
    	 */
    	public boolean contains(Predicate<T> predicate) {
    		return StreamSupport.stream(collection.spliterator(), isParallelized)
    			.anyMatch(predicate)
    		;
    	}
    	
    	/**
    	 * @return
    	 * 	A filtered collection.
    	 * @note
    	 * 	This requires the regrouping of sub-items, and therefore may incur a bottleneck.
    	 */
    	public CollectionExoskeleton<T> filter(Predicate<T> predicate) {
    		return new CollectionExoskeleton<T>(
    			StreamSupport.stream(collection.spliterator(), isParallelized)
    			.filter(predicate)
    			.collect(Collectors.toList()),
    			isParallelized
    		);
    		/*if (isParallelized)
    			return new CollectionExoskeleton<T>(collection.stream().parallel().filter(predicate).collect(Collectors.toList()), isParallelized);
    		else
    			return new CollectionExoskeleton<T>(collection.stream().filter(predicate).collect(Collectors.toList()), isParallelized);*/
    	}
    	
    	public <U> CollectionExoskeleton<U> map(Function<T, U> mapper) {
    		return new CollectionExoskeleton<U>(
    			StreamSupport.stream(collection.spliterator(), isParallelized)
    			.map(mapper)
    			.collect(Collectors.toList()),
    			isParallelized
    		);
    	}
    	
    	/**
    	 * 
    	 * @param mapper
    	 * @return
    	 * 	The items in the collection mapped to a value.
    	 */
    	public <U> Collection<U> mapCollect(Function<T, U> mapper) {
    		if (isParallelized)
    			return parallelMapCollectToList(collection, mapper);
    		else
    			return collection.stream().map(mapper).collect(Collectors.toList());
    	}
    	
    	/**
    	 * 
    	 * @param groups
    	 * @return
    	 * 	The collection, sorted into groups.
    	 */
    	public <U> Grouper<T, U> groupBy(Grouping<U, T> head, Grouping<U, T>... tail) {
    		List<Grouping<U, T>> groups = new LinkedList<>();
    		groups.add(head);
    		groups.addAll(Arrays.asList(tail));
    		return new Grouper(collection, groups);
    	}
    	
    	
    	public DataSetExoskeleton snapshot(ToDoubleFunction<T> x, ToDoubleFunction<T> y) {
    		ExtendedDataSet ds = new ExtendedDataSet(limitMin(1, collection.size()));
    		collection.forEach(thing -> ds.add(x.applyAsDouble(thing), y.applyAsDouble(thing)));
    		return new DataSetExoskeletonOld(ds);
    	}
    	
    }
    
    public static class Chart1DExoskeleton {
    	private Chart1D chart;
    	
    	public Chart1DExoskeletonOld(Chart1D chart) {
    		this.chart = chart;
    	}
    	
    	public Chart1DExoskeleton add(String label, Color color, double value) {
    		ExperimentUtilities.plot(
    			label,
    			color,
    			value,
    			chart
    		);
    		return this;
    	}
    }
    
    public static class PlotExoskeleton {
    	private Chart2DPlot chart;
    	
    	public PlotExoskeletonOld(Chart2DPlot chart) {
    		this.chart = chart;
    	}
    	
    	public PlotExoskeleton add(String label, Color color, DataSet ds) {
    		ExperimentUtilities.plot(
    			label,
    			color,
    			ds,
    			chart
    		);
    		return this;
    	}
    }
    
    public static class TimeStackChartExoskeleton {
    	private TimeStackChart chart;
    	
    	public TimeStackChartExoskeletonOld(TimeStackChart chart) {
    		this.chart = chart;
    	}
    	
    	public TimeStackChartExoskeleton add(String label, Color color, DataSet ds) {
    		ExperimentUtilities.plot(
    			label,
    			color,
    			ds,
    			chart
    		);
    		return this;
    	}
    	
    	public TimeStackChartExoskeleton add(String label, Color color, Supplier<Double> valueSupplier, Agent anyAgent) {
    		ExperimentUtilities.plot(
    			label,
    			color,
    			valueSupplier,
    			chart,
    			anyAgent
    		);
    		return this;
    	}
    }
    
    /**
     * Extends a dataset's capabilities.
     * @author dylan
     *
     */
    public static class DataSetExoskeleton {
    	private ExtendedDataSet data;
    	public DataSetExoskeletonOld(ExtendedDataSet data) {
    		this.data = data;
    	}
    	
    	public DataSetExoskeletonOld(DataSet data) {
    		this.data = ExtendedDataSet.from(data, 0);
    	}
    	
    	public void plot(String label, Color color, Plot plot) {
    		ExperimentUtilities.plot(label, color, data, plot);
    	}
    	
    	public ExtendedDataSet data() {
    		return data;
    	}
    	
    	
    	
    	public String toJson() {
    		 Gson gson = new Gson();
    		 return gson.toJson(data);
    	}
    }
    
    public static class Grouper<T, V> {
    	private Collection<T> things;
    	private List<Grouping<V,T>> groups;
    	
    	public Grouper(
    	    	Collection<T> things,
    	    	List<Grouping<V,T>> groups
    	) {
    		this.things = things;
    		this.groups = groups;
    	}
    	
    	public Map<V, DataSetExoskeleton> snapshot(ToDoubleFunction<T> x, ToDoubleFunction<T> y) {
    		Map<V, DataSetExoskeleton> map = new HashMap<>();
    		groups.forEach(group -> {
    			Collection<T> members = things.stream().filter(group::isMember).collect(Collectors.toList());
        		ExtendedDataSet ds = new ExtendedDataSet(limitMin(1, members.size()));
        		members.forEach(thing -> ds.add(x.applyAsDouble(thing), y.applyAsDouble(thing)));
    			map.put(group.getIdentifier(), new DataSetExoskeletonOld(ds));
    		});
    		return map;
    	}
    	
    	/**
    	 * 
    	 * @param reduction
    	 * @return
    	 * 	Extracts the value for each group.
    	 */
    	public <U> Map<V, U> calculate(Function<List<T>, U> reduction) {
    		return StatisticUtilities.extract(
    			() -> things,
    			reduction,
    			groups
    		).get();
    	}
    }
    
    private static void test() {
    	
    	Collection<String> strings = list("First", "Second", "Third");
    	$(strings).inParallel().percentWhere(string -> string.charAt(0) == 'F');
    	$(strings).sum(String::length);
    	$(strings).inParallel().average(string -> string.hashCode());
    	$(strings)
    		.inParallel()
    		.snapshot(string -> string.length(), string -> string.hashCode())
    		.toJson()
    	;
    	
    	CachedObject<List<Double>> doubles = new CachedObject<>(null, 0d, () -> list(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0));
    	Plot chart = null;
    	$(doubles).inParallel().mapCollect(dub -> dub.intValue() * 2);
    	$(doubles)
    		.inParallel()
    		.filter(v -> v < 9.0)
    		.map(v -> (int)(double)v)
    		.groupBy(
    			grouping("Primes", v -> Primes.isPrime(v)),
    			grouping("Non-Primes", v -> Primes.isPrime(v) == false)
    		)
    		.snapshot(v -> v, v -> v*v)
    		.forEach((id,data) -> data.plot(id, blue, chart));
    	;
    }

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340757</Id>
			<Name><![CDATA[ExtendedDataSet]]></Name>
			<Text><![CDATA[import java.util.AbstractMap;
import java.util.function.*;
import java.util.stream.*;
import java.util.Map.Entry;
import static ca.loif.niceassert.NiceAssert.*;

/**
 * A data set that can be provided with a default value, and that can
 * have its data manipulated more easily than a standard data set.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public class ExtendedDataSet extends DataSet implements Iterable{

	/** 
	 * The default Y value used when required.
	 */
	private Function<ExtendedDataSet, Double> defaultY;
	
	/**
	 * @return
	 * 	A data set with no data that cannot be modified.
	 */
	public static ExtendedDataSet empty() {
		return new ExtendedDataSet(1, 0d) {
			@Override
			public synchronized void add(double x, double y) {
				
			}
			@Override
			public synchronized void add(double x) {
				
			}
		};
	}
    /**
     * Default constructor
     */
    public ExtendedDataSet(int capacity, double defaultY) {
    	this(capacity, ds -> defaultY);
    }
    
    public ExtendedDataSet(int capacity, Function<ExtendedDataSet, Double> defaultY) {
    	super(capacity);
    	this.defaultY = defaultY;
    }
    
    /**
     * Creates the data set, using the most recent Y value (or zero) as the
     * default.
     */
    public ExtendedDataSet(int capacity) {
    	this(capacity, ds -> {
    		
    		if (ds.size() == 0)
    			return 0d;
    		else
    			return ds.getY(ds.size() - 1);
    		
    	});
    }
    

    /**
     * Gets the Y value at the given index.
     */
	@Override
	public synchronized double getY(int i) {
		if (i >= size())
			return defaultY.apply(this);
		
		return super.getY(i);
	}
	
	/**
	 * @return
	 * 	The last Y value added to the dataset.
	 */
	public double getYLast() {
		
		return getY(size()-1);
		
	}
	
	/**
	 * Gets the maximum Y value stored in the data set.
	 */
	@Override
	public double getYMax() {
		if (size() == 0)
			return defaultY.apply(this);
		
		return super.getYMax();
	}

	
	/**
	 * Gets the minimum Y value stored in the data set.
	 */
	@Override
	public double getYMin() {
		if (size() == 0)
			return defaultY.apply(this);
			
		return super.getYMin();
	}

	
	/**
	 * Gets the median Y value stored in the data set.
	 */
	@Override
	public double getYMedian() {
		if (size() == 0)
			return defaultY.apply(this);
		return super.getYMedian();
	}

	
	/**
	 * Gets the mean Y value stored in the data set.
	 */
	@Override
	public double getYMean() {
		if (size() == 0)
			return defaultY.apply(this);
			
		return super.getYMean();
	}

	@Override
	public String toString() {
		return super.toString() + "[DefaultY = " + defaultY+"]";
	}

	/**
	 * Allows the data set to be iterated over.
	 */
	@Override
	public Iterator<Entry<Double, Double>> iterator() {
		
		return new Iterator<Entry<Double, Double>>() {
			
			int index = 0;
			
			@Override
			public boolean hasNext() {
				if (index < size())
					return true;
				else
					return false;
			}
			
			@Override
			public Entry<Double, Double> next() {
				Entry<Double, Double> entry = new AbstractMap.SimpleEntry<Double, Double>(getX(index), getY(index));
				index += 1;
				return entry;
			}
		};
	}
	
	/**
	 * Reduces the data set to a single value.
	 * @param operation
	 * 	A function operating on each (intermediateResult, x, y) tuple in the data set.
	 * @param identity
	 * 	The "starting value" to build from. For a sum reduction, this might be zero, for multiplication, mabye one, etc.
	 */
	public double reduce(double identity, TriFunction<Double, Double, Double, Double> operation) {
		double result = identity;
		for (int i = 0; i < size(); i += 1) {
			result = operation.apply(result, getX(i), getY(i));
		}
		return result;
	}
	
	/**
	 * @return
	 * 	A dataset whose x values match this dataset's x values, but the y values have been
	 *  transformed according to the given mapping function.
	 */
	public ExtendedDataSet map(BiFunction<Double, Double, Double> map) {
		
		ExtendedDataSet ds = new ExtendedDataSet(this.getCapacity(), defaultY);
		
		forEach((x,oldY) -> {
			Double newY = map.apply(x, oldY);
			ds.add(x, newY);
		});
		
		return ds;
		
	}
	
	/**
	 * @return
	 * 	The sum of all Y values in the dataset.
	 */
	public double getYSum() {
		return reduce(0, (totalSoFar, x, y) -> totalSoFar + y);
	}
	
	/**
	 * @return
	 * 	The y values in this dataset.
	 */
	public List<Double> getYValues() {
		return stream().map(kvp -> kvp.getValue()).collect(Collectors.toList());
	}
	
	/**
	 * @return
	 * 	The X values in this dataset.
	 */
	public List<Double> getXValues() {
		return stream().map(kvp -> kvp.getKey()).collect(Collectors.toList());
	}
	
	/**
	 * Streams the data set.
	 */
	public Stream<Entry<Double, Double>> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	
	/**
	 * Allows the action to be performed on each item of the data set.
	 */
	public void forEach(BiConsumer<Double, Double> action) {
		stream().forEach(kvp -> action.accept(kvp.getKey(), kvp.getValue()));
	}
	
	/**
	 * @return
	 * 	Data whose x value is between xStart and xEnd, inclusive.
	 */
	public ExtendedDataSet between(double xStart, double xEnd) {
		ExtendedDataSet subset = new ExtendedDataSet(getCapacity());
		stream()
			.filter(xy -> xStart <= xy.getKey() && xy.getKey() <= xEnd)
			.forEach(xy -> subset.add(xy.getKey(), xy.getValue()))
		;
		return subset;
	}
	
	/**
	 * 
	 * @return
	 * 	The data points whose X values are between (time - modelTimeDuration) and (time) (both inclusive).
	 * @param u
	 * 	A utilities object for getting the current time.
	 * @param modelTimeDuration
	 * 	The time duration, e.g., 3 * year()
	 */
	public ExtendedDataSet last(Utilities u, double modelTimeDuration) {
		assertTrue("Time duration must be greater than zero", modelTimeDuration > 0);
		assertNotNull("Utilities object not provided.", u);
		
		// Return.
		return between(u.time() - modelTimeDuration, u.time());
	}
	
	/**
	 * Constructs an extended data set using the given data set.
	 * @param ds
	 * 	The data set.
	 * @pre ds has at least one item.
	 */
	public static ExtendedDataSet from(DataSet ds, double defaultY) {
		// PReconditions
		if (ds.size() == 0)
			throw new IllegalArgumentException("Data set must have at least one element.");
		
		// Construct.
		ExtendedDataSet toReturn = new ExtendedDataSet(ds.getCapacity(), defaultY);
		DataSetUtilities.forEach(ds, (x,y) -> toReturn.add(x,y));
		
		return toReturn;
	}
	
	/**
	 * @return
	 * 	A data set where each Y value has been revised according to the given function.
	 * /
	public ExtendedDataSet map(BinaryOperator<Double> yRevisor) {
		
		ExtendedDataSet revisedData = new ExtendedDataSet(getCapacity(), defaultY);
		forEach((x,y) -> revisedData.add(x, yRevisor.apply(x,y)));
		return revisedData;
		
	}*/

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340758</Id>
			<Name><![CDATA[Grouping]]></Name>
			<Text><![CDATA[import java.util.function.Predicate;
import static ca.loif.niceassert.NiceAssert.*;
/**
 * A grouping of objects that can be made.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public class Grouping<ID, Member> implements Serializable {
	
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;
	
	/**
	 * Identifies the group. 
	 */
	private ID identifier;
	
	/**
	 * Tests whether an object belongs to the group.
	 */
	private Predicate<Member> membership;
	
	/**
	 * Creates the grouping.
	 * @param identifier
	 * @param membership
	 * 
	 * @pre identifier != null
	 * @pre membership != null
	 */
	public Grouping(ID identifier, Predicate<Member> membership) {
		
		// Preconditions
		assertNotNull("Identifier not provided.", identifier);
		assertNotNull("Membership criteria not provided.", membership);
		
		// Record.
		this.identifier = identifier;
		this.membership = membership;
	}
	
	/**
	 * @return
	 * 	The identifier associated with the grouping.
	 */
	public ID getIdentifier() {
		return identifier;
	}
	
	/**
	 * @param item
	 * @return
	 * 	True, if the item belongs to this grouping.
	 */
	public boolean isMember(Member item) {
		return membership.test(item);
	}
	
	
	/**
	 * A summary of a group.
	 * @author dylan
	 *
	 * /
	public static class Summary<T,U> {
		private T grouping;
		private U summary;
		
		public Summary(T grouping, U summary) {
			this.grouping = grouping;
			this.summary = summary;
		}
		
		public T getGrouping() {
			return grouping;
		}
		
		public U getSummary() {
			return summary;
		}
	}*/

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340759</Id>
			<Name><![CDATA[Intervention]]></Name>
			<Text><![CDATA[import ca.anthrodynamics.toolkit.anylogic.TestSuite.CanScheduleCommands;
import java.util.function.Consumer;
import static ca.anthrodynamics.toolkit.anylogic.HealthUtilities.*;
/**
 * A class for building an intervention quickly and declaratively.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public final class Intervention<T extends Agent, U extends CanScheduleCommands<T>> implements Serializable {
	
	private U scheduler;
	private T target;
	
	private Intervention(T target, U scheduler) {
		this.target = target;
		this.scheduler = scheduler;
	}
	
	/**
	 * Gets ready to schedule an action.
	 * @param year
	 * @param month
	 * @param day
	 * @return
	 */
	public ActionScheduler at(int year, int month, int day) {
		
		return new ActionScheduler() {{
			asParent = Intervention.this;
			time = target.dateToTime(HealthUtilities.at(year, month, day)) - target.time();
			units = target.getEngine().getTimeUnit();
			traceln("Action will occur in " + format(time) + " " + units);
		}};
	}
	
	/**
	 * Used to schedule an action.
	 * @author dylan
	 *
	 */
	public class ActionScheduler {
		protected Intervention<T,U> asParent;
		protected double time;
		protected TimeUnits units;
		
		/**
		 * @return
		 * 	Schedules the thing to do.
		 */
		public NextAction doThis(String description, Consumer<T> thing) {
			scheduler.scheduleCommand(time, units, m -> {
				traceln(description);
				thing.accept(m);
			});
			return new NextAction() {{
				this.naParent = asParent;
				this.time = ActionScheduler.this;
			}};
		}
	}
	
	public class NextAction {
		protected Intervention<T,U> naParent;
		protected ActionScheduler time; 

		public ActionScheduler at(int year, int month, int day) {
			return naParent.at(year, month, day);
		}

		
		/**
		 * @return
		 * 	Schedule another thing to do after this action is done.
		 */
		public NextAction andThis(String description, Consumer<T> thing) {
			return time.doThis(description, thing);
		}
		
		
	}
	
	/**
	 * Internal test hook only.
	 */
	protected void _test() {
		Agent target = null;
		CanScheduleCommands<Agent> scheduler = null;
		given(target, scheduler)
			.at(2017, JANUARY, 30)
			.doThis("Meow", t -> {})
			.at(2017, JUNE, 30)
			.doThis("Woof", t -> {})
		;
	}
	
	public static <T extends Agent, U extends CanScheduleCommands<T>> Intervention<T,U> given(T target, U scheduler) {
		return new Intervention(target, scheduler);
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340760</Id>
			<Name><![CDATA[ModelCitation]]></Name>
			<Text><![CDATA[import de.undercouch.citeproc.csl.CSLItemDataBuilder;

/**
 * Citation for the model. Used to help utility classes ensure citations are
 * always in the format they require.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public class ModelCitation extends CSLItemDataBuilder {
	
	public String name;
	public String creatingClazz;
	
	public ModelCitation(String name, String creatingClazz) {
		this.name = name;
		this.creatingClazz = creatingClazz;
		citationLabel(name);
	}
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340762</Id>
			<Name><![CDATA[Person]]></Name>
			<Text><![CDATA[/**
 * 
 * Contains attributes on a person.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
public interface Person
{
	/**
	 * @return
	 * 	The person's weight in Kg.
	 */
	public double getWeightKg();
	
	/**
	 * @return
	 * 	True, if the person is male.
	 */
	public boolean isMale();
	
	/**
	 * @return
	 * 	The person's height in cm.
	 */
	public double getHeightCm();
	
	/**
	 * @return
	 * 	The person's age in years.
	 */
	public double getAge();
	
	/**
	 * @return
	 * 	The person's BMI.
	 */
	default public double getBMI() {
		// Standard BMI formula.
		return HealthUtilities.getBMI(this);
	}

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340763</Id>
			<Name><![CDATA[Plugin]]></Name>
			<Text><![CDATA[import java.util.Optional;

/**
 * A plugin that can provide data.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
public interface Plugin<Model, EventType>
{
	/**
	 * @return
	 * 	The name of the plugin. By default, this is its class name.
	 */
	public default String getName() {
		return getClass().getSimpleName();
	}
	
	/**
	 * Called when an important event in the model occurs.
	 */
	public void onEvent(EventType event);
	
	public Version getVersion();
	
	
	/**
	 * Tracks the version of a plugin.
	 * 
	 * @author dylan
	 *
	 */
	public class Version {
		private int major;
		private int minor;
		private int patch;
		private Optional<String> tag;
		
		public Version(int major, int minor, int patch, Optional<String> tag) {
			this.major = major;
			this.minor = minor;
			this.patch = patch;
			this.tag = tag;
		}
		
		public Version(int major, int minor, int patch) {
			this(major, minor, patch, Optional.empty());
		}
		
		/**
		 * Produces a string in the form Major.Minor.Version[Tag]
		 */
		@Override
		public String toString() {
			return major + "." + minor + "." + patch + tag.orElse("");
		}
	}

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340772</Id>
			<Name><![CDATA[TestCaseBuilder]]></Name>
			<Text><![CDATA[/**
 * Used to more easily build a test suite.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
@FunctionalInterface
public interface TestCaseBuilder {
	
	public <T> void add(TestSuite<T> suite);
	
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340788</Id>
			<Name><![CDATA[TestRunner]]></Name>
			<ExcludeFromBuild>true</ExcludeFromBuild>
			<Text><![CDATA[import java.util.Optional;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;
import java.util.stream.Stream;

import javax.swing.JFrame;

import ca.anthrodynamics.toolkit.anylogic.TestSuite.*;
import static ca.anthrodynamics.toolkit.anylogic.CollectionUtilities.*;

import java.lang.reflect.*;
import java.nio.channels.FileLock;
import java.nio.channels.OverlappingFileLockException;
import java.io.RandomAccessFile;

import static ca.loif.niceassert.NiceAssert.*;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.OutputStreamWriter;
/**
 * Runs tests built using the {@link TestSuite}.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
public class TestRunner<ToTest> {

	/**
	 * The number of test suites run so far.
	 */
	private static int testSuitesCompleted = 0;
	
    private TestSuite<ToTest> suite;
    private Thread runThread;
    private TestSuite<ToTest>.FinalizedScenario<ToTest> currentScenario;
    private Iterator<TestSuite<ToTest>.FinalizedScenario<ToTest>> scenarios;
    private Map<String, Optional<Throwable>> scenarioOutcomes = new LinkedHashMap<>();
    
    public static File LockFile = new File("test.lock");
    private RandomAccessFile raf;
    private FileLock lock;
    
    /**
     * An optional output file for the final outputs of tests.
     */
    public static Optional<PrintWriter> resultsXML = Optional.of(
    	HealthUtilities.calculate(() -> {
    		try {
    			/*BufferedReader reader = new BufferedReader(new FileReader("results.xml"));
    			traceln("Existing contents: " );
    			reader.lines().forEach(line -> traceln(line));
    			reader.close();*/
    			// Clear the file.
    			
    			FileWriter clear = new FileWriter("results.xml");
    			clear.write("");
    			clear.close();
    			
    			// Begin writing to it.
    			return new PrintWriter(new FileWriter("results.xml", true));
    		}
    		catch (Throwable t) {
    			throw new RuntimeException(t);
    		}
    	})
    );
    public static void clearStandardResultsFile() {

		try {
			FileWriter out = new FileWriter("results.xml", false);
			out.write("");
			out.flush();
			out.close();
		}
		catch (Throwable t) {
			throw new RuntimeException(t);
		}
    }
    
    /**
     * Creates the test runner. Uses the standard test lock to ensure
     * multiple runners are not running simultaneously.
     * @pre at least one suite is provided (May contain no tests).
     */
    public TestRunner(TestSuite<ToTest> suite) {
    	this.suite = suite;
    	
    	
    }
    
    /**
     * Sets the setup code of the test suite.
     * @param action
     */
    public void beforeEachTest(Runnable action) {
    	this.suite.beforeEachTest(action);
    }
    
    /**
     * Sets the teardown code of the test suite.
     * @param action
     */
    public void afterEachTest(Runnable action) {
    	this.suite.afterEachTest(action);
    }
    
    /**
     * Called when the experiment is set up. 
     * @param findLocalTests
     * 	When true, the method will seek all zero-parameter methods that match the pattern
     * 	"test_" and run them with the assumption that they will assemble a
     *  test suite. Does NOT search for inhereted methods.
     */
    public void onExperimentSetup(Object classWhereTestsAreLocated, boolean findTests) {
    	
    	// Wait for other test runners to complete. We don't want to fight them.
    	boolean haveLock = false;
    	while (haveLock == false) {
			try {
		    	raf = new RandomAccessFile(LockFile, "rw");
		    	lock = raf.getChannel().tryLock();
		    	if (lock != null) {
		    		haveLock = true;
		    	}
			}
			catch (OverlappingFileLockException t) {
				try {
					Thread.sleep(100);
				}
				catch (Throwable tt) {
					throw new RuntimeException(tt);
				}
			}
			catch (Throwable t) {
				throw new RuntimeException(t);
			}
    	}
    	
    	// Start the experiment.
    	suite.log("== Experiment Setup ==");
    	
    	// Find and assemble the test suite, if needed.
    	if (findTests) {

    		suite.log("Collecting scenarios.");
    		list(classWhereTestsAreLocated.getClass().getDeclaredMethods())
    			.stream()
    			.filter(test -> test.getName().matches("test_.*"))
    			.sorted((A,B) -> A.getName().compareTo(B.getName()))
    			.forEach(test -> {
    				suite.log("Found test: " + test.getName());
    				test.setAccessible(true);
    		    	try {
    		    		test.invoke(classWhereTestsAreLocated);
    		    	}
			    	catch (Throwable t) {
			    		throw new RuntimeException(t);
			    	}
    			})
    		;
    	}
    	
    	// Then, record the tests we know of so far.
    	scenarios = suite.iterator();
    	suite.log("");
    }
    
    public void onBeforeExperimentRun() {
    	
    	// Get the next scenario.
    	currentScenario = scenarios.next();
    	
    	// Log a message to help see what's going on.
    	suite.log("Next scenario: " + currentScenario.getDescription());
    	suite.log("---------------------------------------------------");

    	// Do setup actions.
    	suite.log("Test Suite Experiment Setup");
    	suite.doTestSetup();
    	
    	suite.log("Test-Specific Experiment Setup");
    	currentScenario.doSetup();
    }
    
    public void onBeforeSimulationRun(ToTest root) {
    	onBeforeSimulationRun(root, false);
    }
    
    public void onBeforeSimulationRun(ToTest root, boolean ignoreCanScheduleCommandsWarning) {
    	
    	// Do setup.
    	suite.log("Scenario Setup. Root: " + root);
    	if (root instanceof Agent && !(root instanceof CanScheduleCommands) && ignoreCanScheduleCommandsWarning == false)
    		throw new Error("Root object is an Agent but does not implement CanScheduleCommands. Any setup code dependent on Agent lists being set up, for example, will fail.");
    	if (root instanceof CanScheduleCommands)
    		((CanScheduleCommands)root).scheduleCommand(0.0, SECOND, r -> currentScenario.run(root));
    	else
    		currentScenario.run(root);
    	
    	
    }
    
    public void onAfterSimulationRun(Experiment experiment, ToTest root) {
    	
    	suite.log("End-of-model tests.");
    	currentScenario.executeEndOfModelActions(root);
    	
    	suite.log("Test-Specific Teardown");
    	currentScenario.doTeardown(root);

    	suite.log("Test Suite Teardown");
    	suite.doTestTeardown();
    	
    	// Record what happened with the scenario.
    	scenarioOutcomes.put(
    		currentScenario.getDescription(),
    		currentScenario.getProblem()
    	);
    	
    	if (scenarios.hasNext()) {
    		runThread = new Thread(() -> {
    		
    			// Spin until the simulation is done.
    			// It annoyingly ends the experiment but continues to process events...
    			do {
    				try {
    					Thread.sleep(50);
    				}
    				catch (Throwable t) {}
    			} while (experiment.getState() != Experiment.IDLE);

        		suite.log("");
    			System.gc();
    			experiment.run();
    		});
    		suite.log("Test done. Waiting on AnyLogic engine...");
    		runThread.start();
    	}
    	else {
    		
    		suite.log("Test done.");
        	suite.log("");
        	suite.log("===== RESULTS: "+suite.experiment.getClass().getSimpleName()+" =====", true);
        	
        	// Figure out how many scenarios passed and failed.
        	int total = scenarioOutcomes.size();
        	int failed = count(scenarioOutcomes.values(), outcome -> outcome.isPresent());
        	
        	// If the XML file for results is present, start building it.
        	if (resultsXML.isPresent()) {
        		resultsXML.get().println("<suite>");
        		resultsXML.get().println("<container>"+suite.experiment.getClass().getSimpleName()+"</container>");
        	}
        	
        	if (failed == 0) {
        		log("summary", "All "+format(total)+" tests succeeded.");
        	}
        	else {
        		log("summary", ""+failed+"/"+total+" tests failed.");
        	
            	if (resultsXML.isPresent())
            		resultsXML.get().println("<failed_scenarios>");
            		
	        	scenarioOutcomes.forEach((scenario, problem) -> {
	        		// If there is a problem, dump it.
	        		if (problem.isPresent()) {
	        			// Dump the scenario name.
	        			suite.log("FAILED SCENARIO: ", true);
	        			if (resultsXML.isPresent())
	        					resultsXML.get().println("<scenario>");
	        			log("scenario_name", scenario); 
	        			
	        			// Dump details.
	        			problem.get().printStackTrace(suite.out);
	        			if (resultsXML.isPresent()) {

	        	    		resultsXML.get().println("<stack_trace>");
	        	    		problem.get().printStackTrace(resultsXML.get());
	        	    		resultsXML.get().println("</stack_trace>");
	        	    		resultsXML.get().println("</scenario>");
	        			}
	        		}
	        	});

	        	if (resultsXML.isPresent())
	        		resultsXML.get().println("</failed_scenarios>");
        	}
        	suite.log("", true);
        	
        	// If the XML file for results is present, wrap it up.
        	if (resultsXML.isPresent()) {
        		resultsXML.get().println("</suite>");
        		resultsXML.get().flush();
        	}

        	try {
        		// And we're done!
        		testSuitesCompleted += 1;
        		
        		lock.release();
        		raf.close();
        	}
        	catch (Throwable t) { throw new RuntimeException(t); }
        	
        	
			//System.exit(0);
        	
        	/*
        	// Figure out how many scenarios passed and failed.
        	int total = scenarioOutcomes.size();
        	int failed = count(scenarioOutcomes.values(), outcome -> outcome.isPresent());
        	
        	if (failed == 0) {
        		suite.log("All "+format(total)+" tests succeeded.", true);
        	}
        	else {
        		suite.log(""+failed+"/"+total+" tests failed.", true);
        	
	        	scenarioOutcomes.forEach((scenario, problem) -> {
	        		if (problem.isPresent()) {
	        			suite.log("FAILED SCENARIO: " + scenario, true);
	        			problem.get().printStackTrace(suite.out);
	        		}
	        	});
        	}
        	suite.log("", true);

        	try {
        		lock.release();
        		raf.close();
        	}
        	catch (Throwable t) { throw new RuntimeException(t); }
			//System.exit(0);
        	 */
    	}
    }
    
    /**
     * Log the message, tagging it for XML output if needed.
     * @param xmlTag
     * @param message
     */
    private void log(String xmlTag, String message) {
    	// If the XML file for results is present, start building a tag.
    	if (resultsXML.isPresent()) {
    		resultsXML.get().println("<"+xmlTag+">");
    	}
    	
    	// Dump to the suite's output logger.
    	suite.log(message, true);
    	
    	// If the XML file for results is present, dump the message too.
    	if (resultsXML.isPresent()) {
    		resultsXML.get().println(message);
    	}
    	
    	// If the XML file for results is present, wrap it up.
    	if (resultsXML.isPresent()) {
    		resultsXML.get().println("</"+xmlTag+">");
    		resultsXML.get().flush();
    	}
    }
    
    /**
     * Allows a scenario to be added.
     * @return
     * 	The scenario to run.
     * @pre test runner has not already hijacked the experiment to run its 
     * 	tests.
     */
    public TestSuite<ToTest> add() {
    	
    	// Precondition check.
    	assertNull(
    		"Test runner has already been started, so no more tests can be submitted.",
    		runThread
    	);
    	
    	return suite;
    }
    
    /**
     * Convenience method to run all tests in the given experiments and dump them to file.
     * Used often from a {@link ExperimentCustom}
     */
    public static void runAllTests(List<Class<? extends ExperimentCompareRuns>> toRun) {
    	// Create the results file.
    	TestRunner.clearStandardResultsFile();
    	TestRunner.resultsXML.get().println("<all_tests>");

    	// Create a function to submit the test classes.
    	List<Future<?>> awaiting = new LinkedList<>();
    	ExecutorService manager = Executors.newCachedThreadPool();
    	Consumer<Class<ExperimentCompareRuns>> submitTestSuite = experimentClass -> {
    		awaiting.add(
    			manager.submit(() -> {
    				try {
    					ExperimentCompareRuns experiment = experimentClass.getConstructor().newInstance();
    					JFrame frame = new JFrame("Tests");
    					experiment.setup(frame);
    					experiment.run();
    					while (experiment.getEngine().getState() != Engine.IDLE) {
    						Thread.yield();
    					}
    				}
    				catch (Exception e) {
    					throw new RuntimeException(e);
    				}
    			})
    		);
    	};

    	// Start the tests.
    	toRun.forEach(clazz -> submitTestSuite.accept((Class<ExperimentCompareRuns>)clazz));

    	// Wait for everything to wrap up execution.
    	awaiting.forEach(next -> {
    		try {
    			next.get();
    		}
    		catch (Throwable t) { 
    			throw new RuntimeException(t); 
    		}
    	});

    	// Wrap up the XML file once all suites have been completely finished.
    	try {
    		while (testSuitesCompleted < toRun.size())
    			Thread.yield();
    	}
    	catch (Throwable t) { 
    		throw new RuntimeException(t); 
    	}
    	TestRunner.resultsXML.get().println("</all_tests>");
    	TestRunner.resultsXML.get().flush();
    }
    
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340789</Id>
			<Name><![CDATA[TestSuite]]></Name>
			<Text><![CDATA[import java.util.function.*;
import java.util.Optional;
import java.io.*;
import java.util.stream.*;

import static ca.loif.niceassert.NiceAssert.*;

/**
 * A collection of tests to be run.
 * 
 <pre>
 
 testSuite
 	.scenario("The base case is run")
 		.given("No unique configuration", model -> {})
 		.then("Population growth should match real data within 10%", model -> checkError(A, B, threshold))
 		.and("Resources should dry up.", model -> ...)
 	.scenario("An intervention is run on a troublesome population.")
 		.given("High delinquency rating configuration", model -> model.set_delinquency(0.90))
 		.when("First year review is due.", 12, MONTH)
 		.then("Jails should be full.", model -> ....)
 		.and("Warden should quit.", model -> ....)
 		.ifFailure("Record conditions that didn't allow jail to fill.", (scenario, model) -> ...)
 		.when("Program review is due.", 24, MONTH)
 		.then("The system should collapse., model -> ...)
 		.ifFailure("Record the state of the prisons.", (scenario, model) -> ...)
 	.<more scenarios>
 ;
 		
 "then" implicitly implies "end of model" unless preceded by "when"

 In a compare runs experiment:
 (V) suite : TestSuite
 
 On Startup:
 suite.run(Consumer<Scenario> callback)
 
 This begins a thread that will run each test. After each test, the callback
 will be called. The suite can then be queried, e.g.:
 
 + getFailedScenarios(): Map<Scenario, Throwable>
 + getCompletedScenarios(): List<Scenario>
 + getNumberOfCompletedScenarios(): Integer
 + getNumberOfScenarios(): Integer
 
 A default interface can also be created, with progress bar and output.
 
 suite.runWithDefaultUI(position)
 
 When a failure occurs, the scenario should be saved.
 
 </pre>
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 */	
public class TestSuite<Thing> implements Iterable<TestSuite<Thing>.FinalizedScenario<Thing>> {
	
	
	public boolean verbose = true;
	/**
	 * Used to write messages to file when things go wrong.
	 */
	protected PrintStream out;
	
	/**
	 * The scenario currently being constructed.
	 */
	private Scenario<Thing> scenarioBeingConstructed;
	
	/**
	 * The scenarios that have been constructed.
	 */
	private List<FinalizedScenario<Thing>> scenarios = new LinkedList<>();
	
	/**
	 * The class of the thing being tested.
	 */
	protected Class<Thing> clazz;
	
	/**
	 * Code to run before each test.
	 */
	private Runnable beforeEachTest;
	
	/**
	 * Code to run after each test.
	 */
	private Runnable afterEachTest;
	
	/**
	 * The experiment running this suite.
	 */
	protected Object experiment;
	

    /**
     * Creates the test suite, recording the logger.
     * @pre log != null
     */
    public TestSuite(Object experiment, OutputStream log, Class<Thing> clazz) {
    	this(experiment, log, clazz, true, () -> {}, () -> {});
    }

    /**
     * Creates the test suite, recording the logger.
     * @pre log != null
     */
    public TestSuite(Object experiment, OutputStream log, Class<Thing> clazz, boolean verbose) {
    	this(experiment, log, clazz, verbose, () -> {}, () -> {});
    }
    
    public void doTestSetup() {
		try {
			// Do test setup.
			beforeEachTest.run();
		}
		catch (Throwable t) {
			t.printStackTrace(out);
		}
    }
    
    public void doTestTeardown() {
		try {
			// Do test setup.
			afterEachTest.run();
		}
		catch (Throwable t) {
			t.printStackTrace(out);
		}
    	
    }

    /**
     * Creates the test suite, recording the logger.
     * @pre log != null
     * @pre beforeEachTest != null
     * @pre afterEachTest != null
     */
    public TestSuite(Object experiment, OutputStream log, Class<Thing> clazz, boolean verbose, Runnable beforeEachTest, Runnable afterEachTest) {
    	// Preconditions
    	assertNotNull("Output log not provided.", log);
    	assertNotNull("Setup code not provided.", beforeEachTest);
    	assertNotNull("Teardown code not provided.", afterEachTest);
    	
    	// Record everything.
    	this.out = new PrintStream(log);
    	this.clazz = clazz;
    	this.verbose = verbose;
    	this.beforeEachTest = beforeEachTest;
    	this.afterEachTest = afterEachTest;
    	this.experiment = experiment;
    }
    
    protected void log(String message, boolean forceWrite) {
    	if (verbose || forceWrite)
    		out.println(message);
    }
    
    protected void log(String message) {
    	log(message, false);
    }
    
    /**
     * Returns a new test suite with the tests from this suite and
     * the given suite. Uses the output stream and verbosity of
     * this test suite. Both this and the extension suites have
     * their scenarios finalized.
     */
    public TestSuite<Thing> and(TestSuite<Thing> extension) {
    	
    	this.finalizeScenarios();
    	extension.finalizeScenarios();
    	
    	TestSuite<Thing> newSuite = new TestSuite(experiment, out, clazz);
    	newSuite.verbose = this.verbose;
    	newSuite.scenarios.addAll(this.scenarios);
    	newSuite.scenarios.addAll(extension.scenarios);
    	
    	return newSuite;
    }
    
    public void beforeEachTest(Runnable action) {
    	this.beforeEachTest = action;
    }
    
    public void afterEachTest(Runnable action) {
    	this.afterEachTest = action;
    }
    
    /**
     * @return
     * 	The number of tests that are ready to run.
     */
    public int getNumberOfFinalizedTests() {
    	return scenarios.size();
    }
    
    /**
     * Begins the creation of a scenario, ending all other scenarios currently
     * being built.
     * @param description
     * 	The description of the scenario.
     * @pre
     * 	Description is unique to any added scenarios.
     */
    public Scenario<Thing> scenario(String description) {
    	return scenario(description, () -> {});
    }
    
    /**
     * Begins the creation of a scenario, ending all other scenarios currently
     * being built.
     * @param description
     * 	The description of the scenario.
     * @pre
     * 	Description is unique to any added scenarios.
     */
    public Scenario<Thing> scenario(String description, Runnable setup) {
    	
    	// Finalize any current scenarios.
    	finalizeScenarios();
    	
    	// If a scenario already exists with this description, fail.
    	if (count(scenarios, s -> s.getDescription().equals(description)) > 0)
    		throw new Error("A new scenario was added, but another scenario already exists with an identical description.");
    	
    	// Start a new scenario.
    	scenarioBeingConstructed = new Scenario<>(this, description);
    	scenarioBeingConstructed.beforeScenarioActions.add(setup);
    	
    	return scenarioBeingConstructed;
    }
    
    /**
     * Finalizes any scenarios currently under construction.
     */
    private void finalizeScenarios() {
    	
    	// Finalize the scenario under construction, if any, then record it.
    	if (scenarioBeingConstructed != null) {
    		FinalizedScenario<Thing> next = new FinalizedScenario<>(scenarioBeingConstructed);
    		scenarios.add(next);
    		scenarioBeingConstructed = null;
    	}
    }
    
    @Override
    public Iterator<FinalizedScenario<Thing>> iterator() {
    	
    	// Finalize any scenarios before getting the iterator.
    	finalizeScenarios();
    	
    	return scenarios.iterator();
    }
    /**
     * Runs all scenarios.
     * @param rootSupplier
     * 	A function to get the root object (or agent) to test.
     * 	This function is called before each scenario is run, allowing the root 
     *  object to be refreshed.
     * @param callback
     * 	The function to call when a scenario has been run. In AnyLogic, this 
     * 	is useful to get pauses.
     * @pre root != null
     * @pre callback != null
     */
    public void run(Supplier<Thing> rootSupplier, Consumer<FinalizedScenario> callback) {
    	// Preconditions
    	assertNotNull("Root supplier not provided.", rootSupplier);
    	assertNotNull("Callback not provided.", callback);
    	
    	// Finalize any scenarios before running.
    	finalizeScenarios();
    	
    	// Run each scenario, doing any follow-up code.
    	forEach(scenario -> {
        	
        	// Possibly log.
        	log(scenario.getDescription());
    		
    		// Get the root, run the scenario, wait for further instructions.
    		Thing root = rootSupplier.get();
    		scenario.run(root);
    		scenario.executeEndOfModelActions(root);
    		callback.accept(scenario);
    		
    	});
    }
    
    /**
     * @return
     * 	The scenarios that have been established. 
     * 	Finalizes any scenarios currently under construction.
     */
    public Stream<FinalizedScenario<Thing>> stream() {
    	// Finalize any scenarios before returning them.
    	finalizeScenarios();
    	
    	return scenarios.stream();
    }
    
    /**
     * Applies the action to each scenario in turn.
     * @param action
     * 	The action to apply.
     * @pre action != null
     */
    /*public void forEach(Consumer<FinalizedScenario> action) {
    	// Precondition
    	assertNotNull("Action not provided.", action);
    	
    	// Finalize any scenarios before doing the for-each.
    	finalizeScenarios();
    	
    	// Iterate and apply the action.
    	scenarios.forEach(action);
    }*/
    
    /**
     * A scenario that can be loaded and then run. The class provides methods
     * to build the scenario using a fluid interface.
     *
     * @param <T>
     * 	The root object on which the scenario will be run.
     */
    public class Scenario<T> {
    	
    	/**
    	 * The test suite containing this scenario.
    	 */
    	protected TestSuite<T> testSuite;
    	
    	/**
    	 * The scenario's description.
    	 */
    	protected String scenarioDescription;
    	
    	/**
    	 * A description of the context of the scenario. E.g., "Given that ...."
    	 */
    	protected String contextDescription;
    	
    	/**
    	 * Actions associated with this scenario.
    	 */
    	protected ActionList<T> actions;
    	
    	/**
    	 * Actions to be run at the end of a model.
    	 */
    	protected ActionList<T> endOfModelActions;
    	
    	/**
    	 * Setup code for the scenario.
    	 */
    	protected Consumer<T> scenarioSetup;
    	
    	/**
    	 * Setup code for the experiment, if needed.
    	 */
    	protected List<Runnable> beforeScenarioActions = new LinkedList<>();
    	
    	/**
    	 * Teardown code for the experiment, if needed.
    	 */
    	protected List<Consumer<T>> afterScenarioActions = new LinkedList<>();
    	
    	/**
    	 * Custom creation logic for the object to be tested.
    	 */
    	protected Supplier<T> customCreationLogic;

    	/**
    	 * Any problems that were encountered while running the scenario.
    	 */
    	protected Optional<Throwable> problem = Optional.empty();
    	
    	//protected List<Consumer<T>> teardownActions;
    	
    	//protected List<FutureCheck<T>> futureChecks = new LinkedList<>();
    	
    	/**
    	 * Creates the scenario.
    	 * @param description
    	 * 	A description of the scenario.
    	 * 	
    	 */
    	public Scenario(TestSuite<T> suite, String description) {
    		
    		// Preconditions
    		assertNotNull("Description not provided.", description);
    		assertNotNull("Test suite not provied.", suite);
    		
    		// Record everything.
    		this.scenarioDescription = description;
    		this.testSuite = suite;
    	}
    	
    	/**
    	 * Records code to run before a scenario is to be run.
    	 * @param description
    	 * @param setup
    	 * @return
    	 * /
    	public Scenario<T> beforeScenario(String description, Runnable setup) {
    		// Sanity check.
    		assertNotNull("Description not given.", description);
    		assertNotNull("Setup not given.", setup);
    		
    		// Chain setup code.
    		beforeScenarioActions.add(setup);
    		
    		// Return this to allow more chaining.
    		return this;
    	}*/
    	
    	/**
    	 * Creates the starting conditions for the scenario.
    	 * @param description
    	 * 	A description of the setup.
    	 * @param setup
    	 * 	The actual setup logic.
    	 * @return
    	 * 	An object for building actions that must be performed in the 
    	 * 	scenario.
    	 * @pre description not null
    	 * @pre setup not null
    	 * @pre this method has not already been called (i.e., each scenario can
    	 * 	only have one setup section)
    	 */
    	public ActionList<T> given(String description, Consumer<T> setup) {
    		// Preconditions
    		assertNotNull("Description not given.", description);
    		assertNotNull("Setup not given.", setup);
    		assertNull("Setup code has already been declared!", this.scenarioSetup);
    		assertNull("Action list already generated.", this.actions);
    		assertNull("Description already set.", this.contextDescription);
    		
    		// Record things.
    		this.contextDescription = description;
    		this.scenarioSetup = setup;
    		
    		// Create the action list to use.
    		this.actions = new ActionList<T>(description, this, true);
    		
    		// Return the action list.
    		return actions;
    	}
    	
    	/**
    	 * Convenience method to produce a scenario in which the default
    	 * scenario setup is used. Equivalent to given(<generic text>, m -> {})
    	 */
    	public ActionList<T> givenDefaultSettings() {
    		return given("Default settings of the test suite.", m -> {});
    	}
    	
    	/**
    	 * Shorthand for "givenDefaultSettings, then at model completion (...)" as some objects do not require
    	 * any setup nor have a concept of time.
    	 * @param description
    	 * @param check
    	 * @return
    	 */
    	public CheckList<T> ensureThat(String description, Check<T> check) {
    		return givenDefaultSettings()
    				.whenModelComplete()
    				.then(description, check)
    		;
    	}
    	
    	/**
    	 * @return
    	 * 	True, if the scenario is ready to be run (i.e., has all required 
    	 *  components), false otherwise.
    	 */
    	public boolean isReadyToRun() {
    		// An action list, description, and setup code should be set.
    		return scenarioDescription != null &&
    			contextDescription	!= null &&
    			scenarioSetup != null &&
    			actions != null &&
    			// Either need an action or an end-of-model action.
    			(actions.isEmpty() == false || (endOfModelActions != null && endOfModelActions.isEmpty() == false))
    		;
    	}
    	
    	/**
    	 * @return
    	 * 	A description of the first detected required component that needs to be built. 
    	 */
    	public Optional<String> getNextRemainingRequiredComponent() {
    		if (scenarioDescription == null)
    			return Optional.of("A description of the scenario");
    		if (contextDescription == null)
    			return Optional.of("A description of the initial conditions of the scenario (i.e., given(...))");
    		if (scenarioSetup == null)
    			return Optional.of("Setup logic, created via given()");
    		if (actions == null)
    			return Optional.of("Action List, started via given()");
    		if (actions.isEmpty() && (endOfModelActions == null || endOfModelActions.isEmpty()))
    			return Optional.of("Actions in the action list, started using then(), when(), whenModelComplete(), etc.");
    		return Optional.empty();
    	}
    }
    

	/**
	 * A command scheduled to execute at a particular time.
	 * @author Dylan L. Knowles
	 *
	 * @param <T>
	 */
	protected class FutureCheck<T> {
		
		public Scenario scenario;
		public String description;
		public double time;
		public TimeUnits units;
		public CheckList<T> actions;
		
		public void schedule(CanScheduleCommands<T> scheduler) {
			
			// Schedule the checks.
			scheduler.scheduleCommand(
				// Set the time to execute the checks.
				time, units, 
				// Define the check logic.
				rootObject -> {
					
					// If there's already been a problem with the test, don't execute the check
					if (scenario.problem.isPresent())
						return;
					
					// Otherwise, try doing the check.
					try {
						actions.execute(rootObject);
					}
					catch (Throwable t) {
						scenario.problem = Optional.ofNullable(t);
					}
					
				}
			);
		}
	}
	
	/**
	 * @return
	 * 	A check that expects an exception of the given type to be thrown from the provided sub-check.
	 */
	public static <T> Check<T> expect(Class<? extends Throwable> expected, Check<T> originalCheck) {
		return root -> {
			boolean threwExpectedException = false;
			try {
				originalCheck.test(root);
			}
			catch (Throwable t) {
				if (expected.isAssignableFrom(t.getClass())) {
					threwExpectedException = true;
				}
				else {
					throw new Error(
						"Wrong exception thrown. Expected " + expected.getName() + ", got " + t.getClass().getName() + "("+t.getMessage()+")",
						t
					);
				}
			}
			if (threwExpectedException == false) {
				throw new Error("Expected exception of type " + expected.getName() + " but none was thrown.");
			}
		};
	}
	
	/**
	 * @return
	 * 	A check that expects an exception of any type to be thrown from the provided sub-check.
	 */
	public static <T> Check<T> expectException(Check<T> originalCheck) {
		return expect(Throwable.class, originalCheck);
	}
    
    /**
     * A list of actions to be performed at a particular time, usually at the end
     * of a model.
     *
     * @param <T>
     */
    public class ActionList<T> implements CanStartNewScenario<T>/*, CanStartNewActionList<T>*/ {
    	
    	/**
    	 * The list of things to do.
    	 */
    	private LinkedList<CanBeExecuted<T>> list = new LinkedList<>();
    	
    	/**
    	 * The scenario calling these actions.
    	 */
    	private Scenario<T> scenario;
    	
    	/**
    	 * The action list's description.
    	 */
    	private String description;
    	
    	private boolean implicitlyEndOfModel = false;
    	
    	/**
    	 * Creates the list.
    	 * @param implicitlyEndOfModel
    	 * 	If true, then a call to then() is equivalent to whenModelComplete().then(), if the object
    	 * 	being tested is temporal.
    	 */
    	public ActionList(String description, Scenario<T> scenario, boolean implicitlyEndOfModel) {
    		
    		// Preconditions.
    		assertNotNull("Scenario not provided.", scenario);
    		assertNotNull("Description not provided.", description);
    		
    		// Capture the scenario.
    		this.scenario = scenario;
    		this.description = description;
    		this.implicitlyEndOfModel = implicitlyEndOfModel;
    	}
    	
    	/**
    	 * @return
    	 * 	The suite's description.
    	 */
    	public String getDescription() {
    		return description;
    	}
    	
    	/**
    	 * Begins a list of things to check. If the entity being checked can
    	 * schedule commands and this is not attached to a particular time,
    	 * it is checked at the beginning of the model.
    	 * @param description
    	 * 	The description of the first thing to check.
    	 * @param check
    	 * 	The check to perform.
    	 * @return
    	 * 	The list of things to check, which can be appended.
    	 * @pre description not null
    	 * @pre check not null
    	 */
    	public CheckList<T> then(String description, Check<T> check) {
    		// Preconditions
    		assertNotNull("Description not provided", description);
    		assertNotNull("First check not provided.", check);
    		
    		// If this is implicitly to be done at the end of the model, do so.
    		if (implicitlyEndOfModel) {

        		// Create the list.
        		return whenModelComplete().then(description, check);
    		}
    		// Otherwise, complete the list as needed here.
    		else {
        		// Create the list.
        		CheckList<T> checks = new CheckList<T>(this);
        		list.add(checks);
        		checks.add(new DescriptiveCheck<>(description, check));
        		return checks;	
    		}
    	}
    	

    	/**
    	 * Schedules a command to be run.
    	 */
    	public When<T> when(String description, double time, TimeUnits unit) {
    		// Ensure time-based commands are allowed.
    		assertTrue(
    			"Can't run time-based scenarios if the thing being tested can't accept time-based commands.", 
    			CanScheduleCommands.class.isAssignableFrom(scenario.testSuite.clazz)
    		);
    		
    		// Start building a check to schedule.
    		When<T> when = new When<>(this, description, time, unit);
    		list.add(root -> when.checkBeingBuilt.schedule(((CanScheduleCommands)root)));
    		return when;
    	}
    	
    	public ActionList<T> whenModelComplete() {
    		// Create the list.
    		if (scenario.endOfModelActions == null)
    			scenario.endOfModelActions = new ActionList<>("Upon model completion:", scenario, false);
    		return scenario.endOfModelActions;
    	}
    	
    	/**
    	 * @return
    	 * 	True, if the list is empty, false otherwise.
    	 */
    	public boolean isEmpty() {
    		return list.isEmpty();
    	}
    	
		public TestSuite<T>.Scenario<T> scenario(String description) {
			// Delegate!
			return scenario.testSuite.scenario(description);
		}
		
		@Override
		public CanStartNewScenario<T> afterScenario(String description, Consumer<T> action) {	
			scenario.afterScenarioActions.add(action);
			return this;
		}
		
		/*@Override
		public CanStartNewScenario<T> beforeScenario(String description, Runnable action) {	
			scenario.beforeScenarioActions.add(action);
			return this;
		}*/
    }
    
    /**
     * A scenario that is ready to be run.
     * @param <T>
     * 	The type of object required to run the scenario.
     */
    public class FinalizedScenario<T> {
    	/**
    	 *  The scenario to run. Do not edit it. 
    	 */
    	protected Scenario<T> scenario;
    	
    	public String getDescription() {
    		return scenario.scenarioDescription;
    	}
    	
    	public void doSetup() {

    		try {
    			scenario.beforeScenarioActions.forEach(action -> action.run());
    		}
    		catch (Throwable t) {
    			t.printStackTrace(out);
    		}
    	}
    	
    	public void doTeardown(T root) {

    		try {
    			scenario.afterScenarioActions.forEach(action -> action.accept(root));
    		}
    		catch (Throwable t) {
    			t.printStackTrace(out);
    		}
    	}
    	

    	/**
    	 * Any problems that were encountered while running the scenario.
    	 */
    	public Optional<Throwable> getProblem() {
    		return scenario.problem;
    	}
    	
    	/**
    	 * Creates the scenario.
    	 * @param scenario
    	 * 	The scenario that can be run.
    	 * @pre scenario != null
    	 * @pre scenario is valid
    	 */
    	private FinalizedScenario(Scenario<T> scenario) {

    		// Preconditions
    		assertNotNull("Scenario was not provided.", scenario);
    		if (!scenario.isReadyToRun())
    			fail("Scenario '"+scenario.scenarioDescription+"' is not complete. It requires " + scenario.getNextRemainingRequiredComponent().get());
    		
    		// Record.
    		this.scenario = scenario;
    	}

    	
    	/**
    	 * Runs the scenario using the given environment.
    	 * @param root
    	 * 	The root agent or class to test.
    	 */
    	public void run(T root) {
    		
    		// Set up the scenario.
    		scenario.scenarioSetup.accept(root);
    		
    		try {
    			
    			// Execute all actions.
    			scenario.actions.list.forEach(action -> action.execute(root));
    		}
    		catch (Throwable t) {
    			scenario.problem = Optional.ofNullable(t.getCause());
    			//throw t;
    		}
    	}
    	
       	/**
    	 * Runs end of model actions.
    	 * @param root
    	 * 	The root agent or class to test.
    	 */
    	public void executeEndOfModelActions(T root) {
    		
    		// Quit if a problem has already occurred.
    		if (getProblem().isPresent())
    			return;
    		
    		// If there's no end-of-model actions to do, don't do them.
    		if (scenario.endOfModelActions == null)
    			return;
    		
    		log(scenario.endOfModelActions.getDescription());
    		
    		try {
    			// Execute all end of model actions.
    			scenario.endOfModelActions.list.forEach(action -> action.execute(root));
    		}
    		catch (Throwable t) {
    			scenario.problem = Optional.ofNullable(t);
    			//throw t;
    		}
    	}
    	
    }
   
    /**
     * Actions to be performed in the future.
     * @author Dylan L. Knowles
     */
    public class When<T> {
    	
    	protected FutureCheck<T> checkBeingBuilt;
    	
    	public When(ActionList<T> parent, String description, double time, TimeUnits units) {
    		// Create the checks to be performed in the future, logging when they are to take place.
    		checkBeingBuilt = new FutureCheck<>();
    		checkBeingBuilt.scenario = parent.scenario;
    		checkBeingBuilt.description = description;
    		checkBeingBuilt.time = time;
    		checkBeingBuilt.units = units;
    		checkBeingBuilt.actions = new CheckList<>(parent);
    	}
    	
    	public CheckList<T> then(String description, Check<T> check) {
    		
    		// Add the check to build.
    		checkBeingBuilt.actions.add(new DescriptiveCheck<T>(description, check));
    		return checkBeingBuilt.actions;
    	}
    }
    
    /**
     * Makes a check (a test). If the test passes, no exception is 
     * thrown. Otherwise, something is thrown.
     */
    @FunctionalInterface
    public interface Check<T> {
    	
    	/**
    	 * Tests the given object for some property, throwing a descriptive 
    	 * exception if it fails to pass the test.
    	 */
    	public void test(T thing) throws Throwable;
    	
    }
    
    /**
     * Attaches a check to a description of that check.
     */
    protected class DescriptiveCheck<T> {
    	
    	public String description;
    	public Check<T> logic;
    	
    	public DescriptiveCheck(String description, Check<T> logic) {
    		
    		// Preconditions.
    		assertNotNull("Description not given.", description);
    		assertNotNull("Check logic not given.", logic);
    		
    		this.description = description;
    		this.logic = thing -> {
    			
    			String suffix = "";
    			if (thing instanceof Agent) {
    				suffix = " at t=" + ((Agent)thing).time(YEAR) + " years.";
    			}
    			
    			log("Checking '"+description+"'"+suffix);
    			
    			logic.test(thing);
    		};
    	}
    }
    
    /**
     * A list of checks to perform.
     */
    public class CheckList<T> implements CanStartNewScenario<T>, /*CanStartNewActionList<T>,*/ CanBeExecuted<T> {
    	
    	/**
    	 * The list containing this list.
    	 */
    	private ActionList<T> parent;
    	
    	/**
    	 * The checks to perform.
    	 */
    	private List<DescriptiveCheck<T>> checks = new LinkedList<>();
    	
    	/**
    	 * The response to perform on failure, if any.
    	 */
    	private Optional<Consumer<T>> failureResponse = Optional.empty();
    	
    	/**
    	 * Creates the list.
    	 * @param parent
    	 * 	The list containign this list and will trigger any checks.
    	 * @pre parent not null
    	 */
    	public CheckList(ActionList<T> parent) {
    		
    		// Preconditions
    		assertNotNull("Parent list not provided.", parent);
    		
    		// Record.
    		this.parent = parent;
    	}
    	
    	/**
    	 * Appends a check to the list.
    	 * @param description
    	 * 	The description of the check.
    	 * @param check
    	 * 	The logic to be performed.
    	 * @pre description != null
    	 * @pre check != null
    	 */
    	public CheckList<T> and(String description, Check<T> check) {

    		// Preconditions.
    		assertNotNull("Description not given.", description);
    		assertNotNull("Check logic not given.", check);
    		
    		// record.
    		checks.add(new DescriptiveCheck<>(description, check));
    		return this;
    	}
    	

    	/**
    	 * Schedules a command to be run.
    	 */
    	public When<T> when(String description, double time, TimeUnits unit) {
    		return parent.when(description, time, unit);
    	}
    	
    	public ActionList<T> whenModelComplete() {
    		return parent.whenModelComplete();
    	}
    	
    	/**
    	 * Adds a response to perform on failure, if any.
    	 * @param description
    	 * 	The description of the response.
    	 * @param response
    	 * 	The response itself.
    	 * @return
    	 * 	A list that can have more actions added to it.
    	 */
    	public ActionList<T> ifFailure(String description, Consumer<T> response) {
    		// Preconditions
    		assertNotNull("Description not given.", description);
    		assertNotNull("Response not given.", response);
    		assertFalse("Response has already been set.", this.failureResponse.isPresent());
    		
    		// Record
    		this.failureResponse = Optional.of(response);
    		
    		// Return the action list containing this check list.
    		return parent;
    	}
    	
    	/**
    	 * Adds a check to the list.
    	 * 
    	 * @pre check not null
    	 */
    	private void add(DescriptiveCheck<T> check) {
    		// Preconditions.
    		assertNotNull("Check not provided.", check);
    		
    		// Record the check.
    		checks.add(check);
    	}
    	
    	/**
    	 * Executes all checks.
    	 */
    	@Override
    	public void execute(T target) {
    		// Execute all checks.
    		checks.forEach(check -> {
    			try {
    				check.logic.test(target);
    			}
    			catch (Throwable t) {
    				if (failureResponse.isPresent())
    					failureResponse.get().accept(target);
    				
    				throw new RuntimeException(check.description + " " + t.getMessage(), t);
    			}
    		});
    		
    	}
    	
    	public TestSuite<T>.Scenario<T> scenario(String description) {
    		// Delegate!
    		return parent.scenario(description);
    	}
		
		/*@Override
		public CanStartNewScenario<T> teardown(String description, Consumer<T> action) {	
			return parent.teardown(description, action);
		}*/

		
		@Override
		public CanStartNewScenario<T> afterScenario(String description, Consumer<T> action) {	
			parent.afterScenario(description, action);
			return this;
		}
		
		/*@Override
		public CanStartNewScenario<T> beforeScenario(String description, Runnable action) {	
			parent.beforeScenario(description, action);
			return this;
		}*/
    }
    
    public interface CanScheduleCommands<T> {
    	public void scheduleCommand(double time, TimeUnits timeUnit, Consumer<T> action);
    }
    
    public interface CanStartNewScenario<T> {

    	
    	public TestSuite<T>.Scenario<T> scenario(String description);
    	
    	/**
    	 * Teardown code.
    	 * @param description
    	 * @param action
    	 * @return
    	 */
    	public CanStartNewScenario<T> afterScenario(String description, Consumer<T> action);
    	
    	/**
    	 * Setup code.
    	 * @param description
    	 * @param action
    	 * @return
    	 */
    	//public CanStartNewScenario<T> beforeScenario(String description, Runnable action);
    }
    
    /**
     * A command or action that can be executed.
     */
    @FunctionalInterface
    public interface CanBeExecuted<T> {
    	public void execute(T target);
    }
    
    /*public static interface CanStartNewActionList<T> {
    	
    	public CheckList<T> whenModelComplete();
    }*/
    
    public static void _languageTest() {
    	TestSuite<Agent> ts = new TestSuite<>(new Object(), System.out, Agent.class);
    	
    	ts
    		.scenario("This is a test.")
    			.given("I set a few parameters.", model -> {})
    			.then("The model should respond apprpriately.", model -> {})
    		.scenario("We do stuff on time.")
    			.given("Some setup to manage time chunks", model -> {})
    			.when("A year has passed", 1, TimeUnits.YEAR)
    				.then("Stuff should happen.", model -> {})
    				.and("More stuff should happen.", model -> {})
    				.ifFailure("Keep a special database of stuff when badd things happen.", scenario -> {})
    			.when("Seven years in", 7, TimeUnits.YEAR)
    				.then("stuff...", model -> {})
    				.ifFailure("uh oh!", scenario -> {})
    			.whenModelComplete()
    				.then("blah blah blah", model -> {})
    	;
    	
    	//ts.forEach(scenario -> scenario.run(null));
    }
}
]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340803</Id>
			<Name><![CDATA[TriConsumer]]></Name>
			<Text><![CDATA[/**
 * Allows three things to be consumed.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@FunctionalInterface
public interface TriConsumer<A, B, C> {

    public void accept(A a, B b, C c);

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340819</Id>
			<Name><![CDATA[TriFunction]]></Name>
			<Text><![CDATA[/**
 * Allows three things to be consumed.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@FunctionalInterface
public interface TriFunction<A, B, C, R> {

    public R apply(A a, B b, C c);

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340820</Id>
			<Name><![CDATA[UnhandledValueException]]></Name>
			<Text><![CDATA[/**
 * Thrown when the programmer forgot to handle a value leading
 * to an invalid program branch, e.g., in a switch statement.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public class UnhandledValueException extends Error {

    /**
     * Default constructor
     */
    public UnhandledValueException(Object value) {
    	super("Unhandled value: " + value);
    }

	@Override
	public String toString() {
		return super.toString();
	}

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1520815340835</Id>
			<Name><![CDATA[WrappedFunctions]]></Name>
			<Text><![CDATA[/**
 * Wrapped functions, which make it easier to build streams where sub-components
 * may throw exceptions.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public class WrappedFunctions implements Serializable {

	@FunctionalInterface
    public static interface Supplier<T> {
    	T get() throws Exception;
    }

	@FunctionalInterface
    public static interface Runnable {
    	void run() throws Exception;
    }
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1537484351270</Id>
			<Name><![CDATA[Exoskeleton]]></Name>
			<Text><![CDATA[import static ca.anthrodynamics.toolkit.anylogic.StatisticUtilities.*;
import static ca.anthrodynamics.toolkit.anylogic.CollectionUtilities.*;
import java.util.function.*;
import java.util.stream.*;
import com.google.gson.Gson;

import org.apache.commons.math3.primes.Primes;

/**
 * Provides methods and classes to greatly extend the powers of 
 * regular AnyLogic classes, collections, and common operations.
 *
 * @author Dylan Knowles
 * @license
 * NOTICE
 * Copyright 2018 Dylan Knowles and worldwide Anthrodynamics Simulation branches (As of 2018, Canada: Anthrodynamics Simulation Services Ltd.; Australia: Anthrodynamics Simulation Services Australia PTY Ltd.)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */	
public class Exoskeleton implements Serializable {

    private Exoskeleton() {}
    
    /**
     * @return
     * 	An exoskeleton for the collection.
     */
    public static <T, U extends Collection<T>> CollectionExoskeleton<T> $(U collection) {
    	return new CollectionExoskeleton<T>(collection, false);
    }
    
    /**
     * @return
     * 	An exoskeleton for the collection.
     */
    public static <T extends Agent, U extends AgentList<T>> CollectionExoskeleton<T> $(U agents) {
    	return new CollectionExoskeleton<T>(asCollection(agents), false);
    }
    
    /**
     * @return
     * 	An exoskeleton for the items in the cached collection.
     */
    public static <T, U extends CachedObject<? extends Collection<T>>> CollectionExoskeleton<T> $(U cachedCollection) {
    	return new CollectionExoskeleton<T>(cachedCollection.get(), false);
    }
    
    public static Chart1DExoskeleton $(Chart1D chart) {
    	return new Chart1DExoskeleton(chart);
    }  
    
    public static PlotExoskeleton $(Chart2DPlot chart) {
    	return new PlotExoskeleton(chart);
    }  
    
    public static TimeStackChartExoskeleton $(TimeStackChart chart) {
    	return new TimeStackChartExoskeleton(chart);
    }
    
    public static DataSetExoskeleton $(DataSet dataset) {
    	return new DataSetExoskeleton(dataset);
    }
    
    private static interface Streamable<T> {
	    public Stream<T> stream();
	    public default Stream<T> stream(boolean parallelize) {
	    	if (parallelize)
	    		return stream().parallel();
	    	else
	    		return stream();
	    }
	    public default Collection<T> collection() {
	    	return stream().collect(Collectors.toList());
	    }
	    public default int size() {
	    	return collection().size();
	    }
    }
    
    private static class StreamableCollection<T> implements Streamable<T> {
    	
    	private Collection<T> collection;
    	public StreamableCollection(Collection<T> collection) {
    		this.collection = unmodifiable(collection);
    	}
    	public Stream<T> stream() {
    		return collection.stream();
    	}
    	public Collection<T> collection() {
    		return collection;
    	}
    }
    
    public static class StreamableStream<T> implements Streamable {
    	private Stream<T> stream;
    	public StreamableStream(Stream<T> stream) {
    		this.stream = stream;
    	}
    	public Stream<T> stream() {
    		return stream;
    	}
    }

    /**
     * Provides easy-access methods for a collection.
     * The collection should be treated as a stream.
     * @author dylan
     *
     * @param <T>
     */
    public static class CollectionExoskeleton<T> {
    	
    	private boolean isParallelized;
    	
    	private Streamable<T> collection;
    	
    	private <U extends Collection<T>> CollectionExoskeleton(U collection, boolean parallelProcessing) {
    		this.collection = new StreamableCollection<>(collection);
    		this.isParallelized = parallelProcessing;
    	}
    	
    	private CollectionExoskeleton(Stream<T> stream, boolean parallelProcessing) {
    		this.collection = new StreamableStream<>(stream);
    		this.isParallelized = parallelProcessing;
    	}
    	
    	private CollectionExoskeleton(Streamable<T> streamable, boolean parallelProcessing) {
    		this.collection = streamable;
    		this.isParallelized = parallelProcessing;
    	}
    	
    	/**
    	 * @return
    	 * 	An exoskeleton optimized for parallelization.
    	 */
    	public CollectionExoskeleton<T> inParallel() {
    		return new CollectionExoskeleton(collection, true);
    	}
    	
    	public int size() {
    		return collection.size();
    	}
    	
    	/**
    	 * @param predicate
    	 * @return
    	 * 	The percentage of items in the collection matching the predicate.
    	 */
    	public double percentWhere(Predicate<T> predicate) {
    		if (isParallelized)
    			return parallelPercentWhere(collection.collection(), predicate);
    		else
    			return StatisticUtilities.percentWhere(collection.collection(), predicate);
    	}
    	
    	/**
    	 * @param value
    	 * @return
    	 * 	The sum of the items in the collection.
    	 */
    	public double sum(ToDoubleFunction<T> value) {
    		if (isParallelized)
    			return parallelSum(collection.collection(), value);
    		else
    			return collection.stream().mapToDouble(value).sum();
    	}
    	
    	/**
    	 * @param value
    	 * @param nanValue
    	 * 	The value to provide when there are no items to average, or if the average produces NaN.
    	 * @return
    	 * 	The average of the items in the collection.
    	 */
    	public double average(ToDoubleFunction<T> value, double nanValue) {
    		if (isParallelized)
    			return parallelAverage(collection.collection(), value, nanValue);
    		else
    			return collection.stream().mapToDouble(value).average().orElse(nanValue);
    	}    	
    	
    	/**
    	 * @param value
    	 * @return
    	 * 	The average of the items in the collection, or NaN if a problem occurs.
    	 */
    	public double average(ToDoubleFunction<T> value) {
    		if (isParallelized)
    			return parallelAverage(collection.collection(), value, Double.NaN);
    		else
    			return collection.stream().mapToDouble(value).average().orElse(Double.NaN);
    	}
    	
    	/**
    	 * @return
    	 * 	The number of items matching the criteria.
    	 */
    	public long count(Predicate<T> predicate) {
    		return collection.stream(isParallelized).filter(predicate).count();
    	}
    	
    	/**
    	 * @return
    	 * 	True, if the collection contains any elements matching the predicate.
    	 */
    	public boolean contains(Predicate<T> predicate) {
    		return collection.stream(isParallelized).anyMatch(predicate);
    	}
    	
    	/**
    	 * @return
    	 * 	A filtered collection.
    	 * @note
    	 * 	This requires the regrouping of sub-items, and therefore may incur a bottleneck.
    	 */
    	public CollectionExoskeleton<T> filter(Predicate<T> predicate) {
    		return new CollectionExoskeleton<T>(
    			collection.stream(isParallelized).filter(predicate),
    			isParallelized
    		);
    		/*if (isParallelized)
    			return new CollectionExoskeleton<T>(collection.stream().parallel().filter(predicate).collect(Collectors.toList()), isParallelized);
    		else
    			return new CollectionExoskeleton<T>(collection.stream().filter(predicate).collect(Collectors.toList()), isParallelized);*/
    	}
    	
    	public <U> CollectionExoskeleton<U> map(Function<T, U> mapper) {
    		return new CollectionExoskeleton<U>(
    			collection
    			.stream(isParallelized)
    			.map(mapper),
    			isParallelized
    		);
    	}
    	
    	public <U> CollectionExoskeleton<U> flatMap(Function<T, Stream<U>> mapper) {
    		return new CollectionExoskeleton<U>(
    			collection
    			.stream(isParallelized)
    			.flatMap(mapper),
    			isParallelized
    		);
    	}
    	
    	/**
    	 * 
    	 * @param mapper
    	 * @return
    	 * 	The items in the collection mapped to a value.
    	 */
    	public <U> Collection<U> mapCollect(Function<T, U> mapper) {
    		return collection
    			.stream(isParallelized)
    			.map(mapper)
    			.collect(Collectors.toList())
    		;
    	}
    	
    	/**
    	 * 
    	 * @param mapper
    	 * @return
    	 * 	The items in the collection mapped to a value.
    	 */
    	public <U> Collection<U> flatMapCollect(Function<T, Stream<U>> mapper) {
    		return collection
    			.stream(isParallelized)
    			.flatMap(mapper)
    			.collect(Collectors.toList())
    		;
    	}
    	
    	/**
    	 * 
    	 * @param groups
    	 * @return
    	 * 	The collection, sorted into groups.
    	 */
    	public <U> Grouper<T, U> groupBy(Grouping<U, T> head, Grouping<U, T>... tail) {
    		List<Grouping<U, T>> groups = new LinkedList<>();
    		groups.add(head);
    		groups.addAll(Arrays.asList(tail));
    		return new Grouper(collection.collection(), groups);
    	}
    	
    	
    	public DataSetExoskeleton snapshot(ToDoubleFunction<T> x, ToDoubleFunction<T> y) {
    		ExtendedDataSet ds = new ExtendedDataSet(limitMin(1, collection.size()));
    		collection.stream().forEach(thing -> ds.add(x.applyAsDouble(thing), y.applyAsDouble(thing)));
    		return new DataSetExoskeleton(ds);
    	}
    	
    	public void forEach(Consumer<T> action) {
    		collection.stream(isParallelized).forEach(action);
    		
    	}
    }
    
    public static class Chart1DExoskeleton {
    	private Chart1D chart;
    	
    	public Chart1DExoskeleton(Chart1D chart) {
    		this.chart = chart;
    	}
    	
    	public Chart1DExoskeleton add(String label, Color color, double value) {
    		ExperimentUtilities.plot(
    			label,
    			color,
    			value,
    			chart
    		);
    		return this;
    	}
    }
    
    public static class PlotExoskeleton {
    	private Chart2DPlot chart;
    	
    	public PlotExoskeleton(Chart2DPlot chart) {
    		this.chart = chart;
    	}
    	
    	public PlotExoskeleton add(String label, Color color, DataSet ds) {
    		ExperimentUtilities.plot(
    			label,
    			color,
    			ds,
    			chart
    		);
    		return this;
    	}
    	
    	public ExtendedDataSet getAverage() {
    		SortedMap<Double, List<Double>> values = new TreeMap<>();
    		
    		for (int i = 0; i < chart.getCount(); i += 1) {
    			DataSet ds = chart.get(i);
    			for (int j = 0; j < ds.size(); j += 1) {
    				double x = ds.getX(j);
    				double y = ds.getY(j);
    				values.putIfAbsent(x, new LinkedList<>());
        			values.get(x).add(y);
    			}
    		}
    		
    		ExtendedDataSet average = new ExtendedDataSet(values.size());
    		values.forEach((x,yList) -> {
        		average.add(x, average(yList, y->y));
    		});
    		return average;
    	}
    }
    
    public static class TimeStackChartExoskeleton {
    	private TimeStackChart chart;
    	
    	public TimeStackChartExoskeleton(TimeStackChart chart) {
    		this.chart = chart;
    	}
    	
    	public TimeStackChartExoskeleton add(String label, Color color, DataSet ds) {
    		ExperimentUtilities.plot(
    			label,
    			color,
    			ds,
    			chart
    		);
    		return this;
    	}
    	
    	public TimeStackChartExoskeleton add(String label, Color color, Supplier<Double> valueSupplier, Agent anyAgent) {
    		ExperimentUtilities.plot(
    			label,
    			color,
    			valueSupplier,
    			chart,
    			anyAgent
    		);
    		return this;
    	}
    }
    
    /**
     * Extends a dataset's capabilities.
     * @author dylan
     *
     */
    public static class DataSetExoskeleton {
    	private ExtendedDataSet data;
    	public DataSetExoskeleton(ExtendedDataSet data) {
    		this.data = data;
    	}
    	
    	public DataSetExoskeleton(DataSet data) {
    		this.data = ExtendedDataSet.from(data, 0);
    	}
    	
    	public void plot(String label, Color color, Plot plot) {
    		ExperimentUtilities.plot(label, color, data, plot);
    	}
    	
    	public ExtendedDataSet data() {
    		return data;
    	}
    	
    	
    	
    	public String toJson() {
    		 Gson gson = new Gson();
    		 return gson.toJson(data);
    	}
    }
    
    public static class Grouper<T, V> {
    	private Collection<T> things;
    	private List<Grouping<V,T>> groups;
    	
    	public Grouper(
    	    	Collection<T> things,
    	    	List<Grouping<V,T>> groups
    	) {
    		this.things = things;
    		this.groups = groups;
    	}
    	
    	public Map<V, DataSetExoskeleton> snapshot(ToDoubleFunction<T> x, ToDoubleFunction<T> y) {
    		Map<V, DataSetExoskeleton> map = new HashMap<>();
    		groups.forEach(group -> {
    			Collection<T> members = things.stream().filter(group::isMember).collect(Collectors.toList());
        		ExtendedDataSet ds = new ExtendedDataSet(limitMin(1, members.size()));
        		members.forEach(thing -> ds.add(x.applyAsDouble(thing), y.applyAsDouble(thing)));
    			map.put(group.getIdentifier(), new DataSetExoskeleton(ds));
    		});
    		return map;
    	}
    	
    	/**
    	 * 
    	 * @param reduction
    	 * @return
    	 * 	Extracts the value for each group.
    	 */
    	public <U> Map<V, U> calculate(Function<List<T>, U> reduction) {
    		return StatisticUtilities.extract(
    			() -> things,
    			reduction,
    			groups
    		).get();
    	}
    }
    
    private static void test() {
    	
    	Collection<String> strings = list("First", "Second", "Third");
    	$(strings).inParallel().percentWhere(string -> string.charAt(0) == 'F');
    	$(strings).sum(String::length);
    	$(strings).inParallel().average(string -> string.hashCode());
    	$(strings)
    		.inParallel()
    		.snapshot(string -> string.length(), string -> string.hashCode())
    		.toJson()
    	;
    	
    	CachedObject<List<Double>> doubles = new CachedObject<>(null, 0d, () -> list(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0));
    	Plot chart = null;
    	$(doubles).inParallel().mapCollect(dub -> dub.intValue() * 2);
    	$(doubles)
    		.inParallel()
    		.filter(v -> v < 9.0)
    		.map(v -> (int)(double)v)
    		.groupBy(
    			grouping("Primes", v -> Primes.isPrime(v)),
    			grouping("Non-Primes", v -> Primes.isPrime(v) == false)
    		)
    		.snapshot(v -> v, v -> v*v)
    		.forEach((id,data) -> data.plot(id, blue, chart));
    	;
    }

}]]></Text>
		</JavaClass>
	</JavaClasses>
    <RequiredLibraryReference>
		<LibraryName><![CDATA[com.anylogic.libraries.processmodeling]]></LibraryName>
		<VersionMajor>8</VersionMajor>
		<VersionMinor>0</VersionMinor>
		<VersionBuild>5</VersionBuild>
    </RequiredLibraryReference>
	<ClassPathEntry>
		<Location><![CDATA[lib/citeproc-java-tool-1.0.1/lib/citeproc-java-1.0.1.jar]]></Location>
		<Imported>false</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<Location><![CDATA[lib/citeproc-java-tool-1.0.1/lib/citeproc-java-tool-1.0.1.jar]]></Location>
		<Imported>false</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<Location><![CDATA[lib/apache-sanselan-incubating-0.97-bin/sanselan-0.97-incubator/sanselan-0.97-incubator.jar]]></Location>
		<Imported>false</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<Location><![CDATA[lib/commons/commons-math3-3.6.1.jar]]></Location>
		<Imported>false</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<Location><![CDATA[lib/gson/gson-2.8.1.jar]]></Location>
		<Imported>false</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<Location><![CDATA[lib/loif-niceassert/niceassert.jar]]></Location>
		<Imported>false</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<Location><![CDATA[lib/poi-3.17/poi-3.17.jar]]></Location>
		<Imported>false</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<Location><![CDATA[lib/poi-3.17/poi-ooxml-3.17.jar]]></Location>
		<Imported>false</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
</Model>
</AnyLogicWorkspace>